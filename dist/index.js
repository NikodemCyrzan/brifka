"use strict";var e=require("node:process"),t=require("node:os"),r=require("node:tty"),o=require("node:fs/promises"),n=require("node:path"),s=require("node:crypto"),i=require("fs"),a=require("path"),c=require("tls"),l=require("util"),d=require("net"),u=require("stream");const h=(e=0)=>t=>`[${t+e}m`,p=(e=0)=>t=>`[${38+e};5;${t}m`,f=(e=0)=>(t,r,o)=>`[${38+e};2;${t};${r};${o}m`,m={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],overline:[53,55],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],blackBright:[90,39],gray:[90,39],grey:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgGray:[100,49],bgGrey:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};Object.keys(m.modifier);Object.keys(m.color),Object.keys(m.bgColor);const g=function(){const e=new Map;for(const[t,r]of Object.entries(m)){for(const[t,o]of Object.entries(r))m[t]={open:`[${o[0]}m`,close:`[${o[1]}m`},r[t]=m[t],e.set(o[0],o[1]);Object.defineProperty(m,t,{value:r,enumerable:!1})}return Object.defineProperty(m,"codes",{value:e,enumerable:!1}),m.color.close="[39m",m.bgColor.close="[49m",m.color.ansi=h(),m.color.ansi256=p(),m.color.ansi16m=f(),m.bgColor.ansi=h(10),m.bgColor.ansi256=p(10),m.bgColor.ansi16m=f(10),Object.defineProperties(m,{rgbToAnsi256:{value:(e,t,r)=>e===t&&t===r?e<8?16:e>248?231:Math.round((e-8)/247*24)+232:16+36*Math.round(e/255*5)+6*Math.round(t/255*5)+Math.round(r/255*5),enumerable:!1},hexToRgb:{value(e){const t=/[a-f\d]{6}|[a-f\d]{3}/i.exec(e.toString(16));if(!t)return[0,0,0];let[r]=t;3===r.length&&(r=[...r].map((e=>e+e)).join(""));const o=Number.parseInt(r,16);return[o>>16&255,o>>8&255,255&o]},enumerable:!1},hexToAnsi256:{value:e=>m.rgbToAnsi256(...m.hexToRgb(e)),enumerable:!1},ansi256ToAnsi:{value(e){if(e<8)return 30+e;if(e<16)return e-8+90;let t,r,o;if(e>=232)t=(10*(e-232)+8)/255,r=t,o=t;else{const n=(e-=16)%36;t=Math.floor(e/36)/5,r=Math.floor(n/6)/5,o=n%6/5}const n=2*Math.max(t,r,o);if(0===n)return 30;let s=30+(Math.round(o)<<2|Math.round(r)<<1|Math.round(t));return 2===n&&(s+=60),s},enumerable:!1},rgbToAnsi:{value:(e,t,r)=>m.ansi256ToAnsi(m.rgbToAnsi256(e,t,r)),enumerable:!1},hexToAnsi:{value:e=>m.ansi256ToAnsi(m.hexToAnsi256(e)),enumerable:!1}}),m}();function w(t,r=(globalThis.Deno?globalThis.Deno.args:e.argv)){const o=t.startsWith("-")?"":1===t.length?"-":"--",n=r.indexOf(o+t),s=r.indexOf("--");return-1!==n&&(-1===s||n<s)}const{env:y}=e;let _;function T(r,{streamIsTTY:o,sniffFlags:n=!0}={}){const s=function(){if("FORCE_COLOR"in y)return"true"===y.FORCE_COLOR?1:"false"===y.FORCE_COLOR?0:0===y.FORCE_COLOR.length?1:Math.min(Number.parseInt(y.FORCE_COLOR,10),3)}();void 0!==s&&(_=s);const i=n?_:s;if(0===i)return 0;if(n){if(w("color=16m")||w("color=full")||w("color=truecolor"))return 3;if(w("color=256"))return 2}if("TF_BUILD"in y&&"AGENT_NAME"in y)return 1;if(r&&!o&&void 0===i)return 0;const a=i||0;if("dumb"===y.TERM)return a;if("win32"===e.platform){const e=t.release().split(".");return Number(e[0])>=10&&Number(e[2])>=10586?Number(e[2])>=14931?3:2:1}if("CI"in y)return"GITHUB_ACTIONS"in y||"GITEA_ACTIONS"in y?3:["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","BUILDKITE","DRONE"].some((e=>e in y))||"codeship"===y.CI_NAME?1:a;if("TEAMCITY_VERSION"in y)return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(y.TEAMCITY_VERSION)?1:0;if("truecolor"===y.COLORTERM)return 3;if("xterm-kitty"===y.TERM)return 3;if("TERM_PROGRAM"in y){const e=Number.parseInt((y.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(y.TERM_PROGRAM){case"iTerm.app":return e>=3?3:2;case"Apple_Terminal":return 2}}return/-256(color)?$/i.test(y.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(y.TERM)||"COLORTERM"in y?1:a}function v(e,t={}){return function(e){return 0!==e&&{level:e,hasBasic:!0,has256:e>=2,has16m:e>=3}}(T(e,{streamIsTTY:e&&e.isTTY,...t}))}w("no-color")||w("no-colors")||w("color=false")||w("color=never")?_=0:(w("color")||w("colors")||w("color=true")||w("color=always"))&&(_=1);const b={stdout:v({isTTY:r.isatty(1)}),stderr:v({isTTY:r.isatty(2)})};function E(e,t,r){let o=e.indexOf(t);if(-1===o)return e;const n=t.length;let s=0,i="";do{i+=e.slice(s,o)+t+r,s=o+n,o=e.indexOf(t,s)}while(-1!==o);return i+=e.slice(s),i}const{stdout:k,stderr:S}=b,O=Symbol("GENERATOR"),C=Symbol("STYLER"),D=Symbol("IS_EMPTY"),I=["ansi","ansi","ansi256","ansi16m"],$=Object.create(null),A=e=>{const t=(...e)=>e.join(" ");return((e,t={})=>{if(t.level&&!(Number.isInteger(t.level)&&t.level>=0&&t.level<=3))throw new Error("The `level` option should be an integer from 0 to 3");const r=k?k.level:0;e.level=void 0===t.level?r:t.level})(t,e),Object.setPrototypeOf(t,P.prototype),t};function P(e){return A(e)}Object.setPrototypeOf(P.prototype,Function.prototype);for(const[e,t]of Object.entries(g))$[e]={get(){const r=x(this,F(t.open,t.close,this[C]),this[D]);return Object.defineProperty(this,e,{value:r}),r}};$.visible={get(){const e=x(this,this[C],!0);return Object.defineProperty(this,"visible",{value:e}),e}};const R=(e,t,r,...o)=>"rgb"===e?"ansi16m"===t?g[r].ansi16m(...o):"ansi256"===t?g[r].ansi256(g.rgbToAnsi256(...o)):g[r].ansi(g.rgbToAnsi(...o)):"hex"===e?R("rgb",t,r,...g.hexToRgb(...o)):g[r][e](...o),M=["rgb","hex","ansi256"];for(const e of M){$[e]={get(){const{level:t}=this;return function(...r){const o=F(R(e,I[t],"color",...r),g.color.close,this[C]);return x(this,o,this[D])}}};$["bg"+e[0].toUpperCase()+e.slice(1)]={get(){const{level:t}=this;return function(...r){const o=F(R(e,I[t],"bgColor",...r),g.bgColor.close,this[C]);return x(this,o,this[D])}}}}const L=Object.defineProperties((()=>{}),{...$,level:{enumerable:!0,get(){return this[O].level},set(e){this[O].level=e}}}),F=(e,t,r)=>{let o,n;return void 0===r?(o=e,n=t):(o=r.openAll+e,n=t+r.closeAll),{open:e,close:t,openAll:o,closeAll:n,parent:r}},x=(e,t,r)=>{const o=(...e)=>j(o,1===e.length?""+e[0]:e.join(" "));return Object.setPrototypeOf(o,L),o[O]=e,o[C]=t,o[D]=r,o},j=(e,t)=>{if(e.level<=0||!t)return e[D]?"":t;let r=e[C];if(void 0===r)return t;const{openAll:o,closeAll:n}=r;if(t.includes(""))for(;void 0!==r;)t=E(t,r.close,r.open),r=r.parent;const s=t.indexOf("\n");return-1!==s&&(t=function(e,t,r,o){let n=0,s="";do{const i="\r"===e[o-1];s+=e.slice(n,i?o-1:o)+t+(i?"\r\n":"\n")+r,n=o+1,o=e.indexOf("\n",n)}while(-1!==o);return s+=e.slice(n),s}(t,n,o,s)),o+t+n};Object.defineProperties(P.prototype,$);const N=P();P({level:S?S.level:0});class W{args;index=0;constructor(e){this.args=e}next(){return!(this.index>=this.args.length)&&this.args[this.index++]}prev(){return!(this.index-1<0)&&this.args[--this.index]}peek(){return!(this.index>=this.args.length)&&this.args[this.index]}}const U=(e,t="")=>{const r=[],o=Math.min(process.stdout.columns,45),n=e.split(" ");r.push(`â•­â•´${t}â•¶${Array(o-5-t.length).fill("â”€").join("")}â”€â•®`);let s=[];for(let e=0;e<n.length;e++)if([...s,n[e]].join(" ").length<o-2)s.push(n[e]);else{const t=s.join(" ");r.push(`â”‚${t}${Array(o-2-t.length).fill(" ").join("")}â”‚`),s=[],e--}return s.length>0&&r.push(`â”‚${s.join(" ")}${Array(o-2-s.join(" ").length).fill(" ").join("")}â”‚`),r.push(`â•°${Array(o-2).fill("â”€").join("")}â•¯`),`\n${r.join("\n")}\n`},G=N.yellow,q=N.blue,B={init:`${q("init")}\n\n\tCreates new brifka repository in current working path.`,log:`${q("log\nlog full")}\n\n\tDisplays informations about not tracked and tracked files.\n\t${G("full")} - displays more informations.`,track:`${q("track <directory_path> | <file_path>")}\n\n\tAdds files to the tracked stage.\n\t${G("<directory_path>")} - all files and directories in that directory will be tracked.\n\t${G("<file_path>")} - file will be tracked.`,untrack:`${q("untrack <directory_path> | <file_path> | .")}\n\n\tRemoves files from tracked stage.\n\t${G("<directory_path>")} - all files and directories in that directory will be untracked.\n\t${G("<file_path>")} - file will be untracked.\n\t${G(".")} - all files  will be untracked.`,commit:`${q("commit <commit_name>")}\n\n\tAdds new commit to the repository.\n\t${G("<commit_name>")} - name of new commit.`,uncommit:`${q("uncommit")}\n\n\tRemoves last commit from the repository.`,commits:`${q("commits")}\n${q("commits <limit>")}\n\n\tDisplays commits.\n\t${G("<limit>")} - displays only last x commits.`,change:`${q("change <commit_hash>")}\n\n\tChanges commit that is currently loaded.\n\t${G("<commit_hash>")} - hash of commit which you want to load.`,push:`${q("push")}\n\n\tSends repository to the ftp server specified in 'brifka.config.json'.`,pull:`${q("pull")}\n\n\tDownloads repository from ftp server specified in 'brifka.config.json'.`},K=async(e,t="")=>{const r=n.normalize(e),s=n.parse(r).dir.split(n.sep).filter((e=>e.length>0));e=n.resolve(process.cwd(),r);for(let e=0;e<s.length;e++)try{await o.mkdir(n.resolve(process.cwd(),...s.slice(0,e+1)))}catch{}await o.writeFile(e,t)},H=async(e,t)=>{const r=n.normalize(e),s=n.parse(r).dir.split(n.sep).filter((e=>e.length>0));e=n.resolve(process.cwd(),r);for(let e=0;e<s.length;e++)try{await o.mkdir(n.resolve(process.cwd(),...s.slice(0,e+1)))}catch{}await o.appendFile(e,t)};async function z(e,t){e=n.resolve(process.cwd(),e);try{return t?[!0,t(await o.readFile(e,{encoding:"utf8"}))]:[!0,await o.readFile(e,{encoding:"utf8"})]}catch{return[!1]}}const Y=async(e,t,r)=>{const s=await o.readdir(e);for(const i of s)try{const s=n.resolve(e,i),a=await o.stat(s);if(r&&r.has(n.relative(process.cwd(),s)))continue;a.isDirectory()?await Y(s,t,r):a.isFile()&&t.add(n.relative(process.cwd(),s))}catch{}};const V={...Object.freeze({__proto__:null,CONFIG_FORMAT_ERROR:"Format of config file is not valid.",CONFIG_NOT_EXISTING:"Couldn't load config file."}),...Object.freeze({__proto__:null,TRACKED_DOES_NOT_EXIST:e=>`File or directory '${e}' doesn't exist.`,TRACKED_EMPTY:"There aren't any files in tracked stage.",TRACKED_FILE_NOT_EXISTING:"Repository memory corrupted :/",TRACKED_FILE_WAS_NOT_TRACKED:e=>`File '${e}' wasn't tracked.`,TRACKED_PATHS_ADDED:(e,t)=>`${N.green(e)} new files added to tracked stage from directory '${t}'.`,TRACKED_PATHS_REMOVED:(e,t)=>`${N.red(e)} files removed from tracked stage from directory '${t}'.`,TRACKED_PATH_ADDED:e=>`Added '${e}' to tracked stage.`,TRACKED_PATH_ALREADY_TRACKED:e=>`File '${e}' is already tracked.`,TRACKED_REMOVED_FILE:e=>`Removed '${e}' from tracked stage.`,TRACK_NO_ARGUMENT:"Track command requires <directory_path> | <file_path> argument.",UNTRACK_NO_ARGUMENT:"Untrack command requires <directory_path> | <file_path> argument."}),...Object.freeze({__proto__:null,COMMITS_EMPTY:"There aren't commits yet.",COMMIT_DOES_NOT_EXIST:e=>`Commit with hash '${e}' doesn't exist.`,COMMIT_INFO:(e,t,r)=>`${N.yellow(`commit: ${e}`)}\nDate: ${new Date(t).toLocaleString()}\n\n\t${r}`,COMMIT_NOT_EXISTING:"Couldn't load commits file.",COMMIT_NO_ARGUMENT:"Commit command requires <commit_name> argument.",COMMIT_REMOVE_SUCCESS:"Successfully removed last commit.",COMMIT_SUCCESS:"Successfully commited."}),...Object.freeze({__proto__:null,CHANGE_NO_ARGUMENT:"Change command requires <commit_hash> argument."}),...Object.freeze({__proto__:null,INIT_SUCCESS:"Successfully initialized repository."})},X=n.join(".brifka","mem"),J=n.join(X,"commits"),Z=n.join(X,"head"),Q=n.join(X,"tracked"),ee=n.join(".brifka","rep"),te=e=>n.join(ee,e.slice(0,8)),re="brifka.config.json",oe=e=>e.join(t.EOL),ne=e=>e.split(t.EOL).filter((e=>e.length>0)),se=e=>e.map((({title:e,hash:t,timestamp:r})=>{const o=r.toString();return`${e.length}${e}${o.length}${o}${t}`})).join(t.EOL),ie=e=>{const r=e.split(t.EOL),o=[];try{r.forEach((e=>{if(e.length<=0)return;let t=0,r="";for(;""!=e[t]&&t<e.length;t++)r+=e[t];if(++t>=e.length)throw new Error;let n="",s=t;for(;t<e.length&&t<s+Number(r);t++)n+=e[t];if(""!=e[t])throw new Error;if(++t>=e.length)throw new Error;let i="";for(;""!=e[t]&&t<e.length;t++)i+=e[t];if(++t>=e.length)throw new Error;let a="";for(s=t;t<e.length&&t<s+Number(i);t++)a+=e[t];if(++t>=e.length)throw new Error;let c="";for(;t<e.length;t++)c+=e[t];o.push({title:n,hash:c,timestamp:Number(a)})}))}catch{throw new Error("Couldn't parse commits.")}return o},ae=e=>{const r=e.split(t.EOL),o=[];try{r.forEach((e=>{if(e.length<=0)return;let t=0,r="";for(;""!=e[t]&&t<e.length;t++)r+=e[t];if(++t>=e.length)throw new Error;let n="";for(;t<e.length&&t<r.length+1+Number(r);t++)n+=e[t];if(""!=e[t])throw new Error;if(++t>=e.length)throw new Error;let s="";for(;t<e.length;t++)s+=e[t];o.push({path:n,hash:s})}))}catch{throw new Error("Could't parse tree.")}return o},ce=e=>e.split(t.EOL),le=[".brifka"],de=async(e,t)=>{const[r,o]=await z(e);r&&await K(te(t),o)},ue=new Set([".brifka",re]),he=async e=>{const t=await o.readdir(e);let r=0;for(const s of t){const t=`${e}/${s}`,i=await o.stat(t);if(ue.has(n.relative(process.cwd(),t)))i.isFile()&&r++;else if(i.isFile())await o.unlink(t);else{await he(t)<=0&&await o.rmdir(t)}}return r},pe=[".brifka","brifka.config.json"],fe=[];let me,ge=!0,we=!1,ye="";const _e=()=>{let e;e=we?[!1,ye]:[!0,me],fe.forEach((t=>t(e)))};(async()=>{const[e,t]=await z(re);if(!e)return ge=!1,we=!0,ye=V.CONFIG_NOT_EXISTING,void _e();try{me=JSON.parse(t)}catch{we=!0,ye=V.CONFIG_FORMAT_ERROR}ge=!1,_e()})();const Te=async()=>ge?new Promise((e=>fe.push(e))):we?[!1,ye]:[!0,me];var ve="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},be={},Ee={},ke={},Se={};Object.defineProperty(Se,"__esModule",{value:!0}),Se.positiveIntermediate=Se.positiveCompletion=Se.isMultiline=Se.isSingleLine=Se.parseControlResponse=void 0;function Oe(e){return/^\d\d\d(?:$| )/.test(e)}function Ce(e){return/^\d\d\d-/.test(e)}function De(e){return""!==e.trim()}Se.parseControlResponse=function(e){const t=e.split(/\r?\n/).filter(De),r=[];let o,n=0;for(let e=0;e<t.length;e++){const s=t[e];if(o)o.test(s)&&(o=void 0,r.push(t.slice(n,e+1).join("\n")));else if(Ce(s)){const t=s.substr(0,3);o=new RegExp(`^${t}(?:$| )`),n=e}else Oe(s)&&r.push(s)}return{messages:r,rest:o?t.slice(n).join("\n")+"\n":""}},Se.isSingleLine=Oe,Se.isMultiline=Ce,Se.positiveCompletion=function(e){return e>=200&&e<300},Se.positiveIntermediate=function(e){return e>=300&&e<400},Object.defineProperty(ke,"__esModule",{value:!0}),ke.FTPContext=ke.FTPError=void 0;const Ie=d,$e=Se;class Ae extends Error{constructor(e){super(e.message),this.name=this.constructor.name,this.code=e.code}}function Pe(){}ke.FTPError=Ae;ke.FTPContext=class{constructor(e=0,t="utf8"){this.timeout=e,this.verbose=!1,this.ipFamily=void 0,this.tlsOptions={},this._partialResponse="",this._encoding=t,this._socket=this.socket=this._newSocket(),this._dataSocket=void 0}close(){const e=this._task?"User closed client during task":"User closed client",t=new Error(e);this.closeWithError(t)}closeWithError(e){this._closingError||(this._closingError=e,this._closeControlSocket(),this._closeSocket(this._dataSocket),this._passToHandler(e),this._stopTrackingTask())}get closed(){return void 0===this.socket.remoteAddress||void 0!==this._closingError}reset(){this.socket=this._newSocket()}get socket(){return this._socket}set socket(e){if(this.dataSocket=void 0,this.tlsOptions={},this._partialResponse="",this._socket){e.localPort===this._socket.localPort?this._removeSocketListeners(this.socket):this._closeControlSocket()}e&&(this._closingError=void 0,e.setTimeout(0),e.setEncoding(this._encoding),e.setKeepAlive(!0),e.on("data",(e=>this._onControlSocketData(e))),e.on("end",(()=>this.closeWithError(new Error("Server sent FIN packet unexpectedly, closing connection.")))),e.on("close",(e=>{e||this.closeWithError(new Error("Server closed connection unexpectedly."))})),this._setupDefaultErrorHandlers(e,"control socket")),this._socket=e}get dataSocket(){return this._dataSocket}set dataSocket(e){this._closeSocket(this._dataSocket),e&&(e.setTimeout(0),this._setupDefaultErrorHandlers(e,"data socket")),this._dataSocket=e}get encoding(){return this._encoding}set encoding(e){this._encoding=e,this.socket&&this.socket.setEncoding(e)}send(e){const t=e.startsWith("PASS")?"> PASS ###":`> ${e}`;this.log(t),this._socket.write(e+"\r\n",this.encoding)}request(e){return this.handle(e,((e,t)=>{e instanceof Error?t.reject(e):t.resolve(e)}))}handle(e,t){if(this._task){const e=new Error("User launched a task while another one is still running. Forgot to use 'await' or '.then()'?");e.stack+=`\nRunning task launched at: ${this._task.stack}`,this.closeWithError(e)}return new Promise(((r,o)=>{if(this._task={stack:(new Error).stack||"Unknown call stack",responseHandler:t,resolver:{resolve:e=>{this._stopTrackingTask(),r(e)},reject:e=>{this._stopTrackingTask(),o(e)}}},this._closingError){const e=new Error(`Client is closed because ${this._closingError.message}`);return e.stack+=`\nClosing reason: ${this._closingError.stack}`,e.code=void 0!==this._closingError.code?this._closingError.code:"0",void this._passToHandler(e)}this.socket.setTimeout(this.timeout),e&&this.send(e)}))}log(e){this.verbose&&console.log(e)}get hasTLS(){return"encrypted"in this._socket}_stopTrackingTask(){this.socket.setTimeout(0),this._task=void 0}_onControlSocketData(e){this.log(`< ${e}`);const t=this._partialResponse+e,r=(0,$e.parseControlResponse)(t);this._partialResponse=r.rest;for(const e of r.messages){const t=parseInt(e.substr(0,3),10),r={code:t,message:e},o=t>=400?new Ae(r):void 0;this._passToHandler(o||r)}}_passToHandler(e){this._task&&this._task.responseHandler(e,this._task.resolver)}_setupDefaultErrorHandlers(e,t){e.once("error",(e=>{e.message+=` (${t})`,this.closeWithError(e)})),e.once("close",(e=>{e&&this.closeWithError(new Error(`Socket closed due to transmission error (${t})`))})),e.once("timeout",(()=>{e.destroy(),this.closeWithError(new Error(`Timeout (${t})`))}))}_closeControlSocket(){this._removeSocketListeners(this._socket),this._socket.on("error",Pe),this.send("QUIT"),this._closeSocket(this._socket)}_closeSocket(e){e&&(this._removeSocketListeners(e),e.on("error",Pe),e.destroy())}_removeSocketListeners(e){e.removeAllListeners(),e.removeAllListeners("timeout"),e.removeAllListeners("data"),e.removeAllListeners("end"),e.removeAllListeners("error"),e.removeAllListeners("close"),e.removeAllListeners("connect")}_newSocket(){return new Ie.Socket}};var Re,Me={},Le={},Fe={};Object.defineProperty(Fe,"__esModule",{value:!0}),Fe.FileInfo=Fe.FileType=void 0,function(e){e[e.Unknown=0]="Unknown",e[e.File=1]="File",e[e.Directory=2]="Directory",e[e.SymbolicLink=3]="SymbolicLink"}(Re||(Fe.FileType=Re={}));class xe{constructor(e){this.name=e,this.type=Re.Unknown,this.size=0,this.rawModifiedAt="",this.modifiedAt=void 0,this.permissions=void 0,this.hardLinkCount=void 0,this.link=void 0,this.group=void 0,this.user=void 0,this.uniqueID=void 0,this.name=e}get isDirectory(){return this.type===Re.Directory}get isSymbolicLink(){return this.type===Re.SymbolicLink}get isFile(){return this.type===Re.File}get date(){return this.rawModifiedAt}set date(e){this.rawModifiedAt=e}}Fe.FileInfo=xe,xe.UnixPermission={Read:4,Write:2,Execute:1},Object.defineProperty(Le,"__esModule",{value:!0}),Le.transformList=Le.parseLine=Le.testLine=void 0;const je=Fe,Ne=new RegExp("(\\S+)\\s+(\\S+)\\s+(?:(<DIR>)|([0-9]+))\\s+(\\S.*)");Le.testLine=function(e){return/^\d{2}/.test(e)&&Ne.test(e)},Le.parseLine=function(e){const t=e.match(Ne);if(null===t)return;const r=t[5];if("."===r||".."===r)return;const o=new je.FileInfo(r);return"<DIR>"===t[3]?(o.type=je.FileType.Directory,o.size=0):(o.type=je.FileType.File,o.size=parseInt(t[4],10)),o.rawModifiedAt=t[1]+" "+t[2],o},Le.transformList=function(e){return e};var We={};Object.defineProperty(We,"__esModule",{value:!0}),We.transformList=We.parseLine=We.testLine=void 0;const Ue=Fe,Ge=new RegExp("([bcdelfmpSs-])(((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]?)))\\+?\\s*(\\d+)\\s+(?:(\\S+(?:\\s\\S+)*?)\\s+)?(?:(\\S+(?:\\s\\S+)*)\\s+)?(\\d+(?:,\\s*\\d+)?)\\s+((?:\\d+[-/]\\d+[-/]\\d+)|(?:\\S{3}\\s+\\d{1,2})|(?:\\d{1,2}\\s+\\S{3})|(?:\\d{1,2}æœˆ\\s+\\d{1,2}æ—¥))\\s+((?:\\d+(?::\\d+)?)|(?:\\d{4}å¹´))\\s(.*)");function qe(e,t,r){let o=0;"-"!==e&&(o+=Ue.FileInfo.UnixPermission.Read),"-"!==t&&(o+=Ue.FileInfo.UnixPermission.Write);const n=r.charAt(0);return"-"!==n&&n.toUpperCase()!==n&&(o+=Ue.FileInfo.UnixPermission.Execute),o}We.testLine=function(e){return Ge.test(e)},We.parseLine=function(e){const t=e.match(Ge);if(null===t)return;const r=t[21];if("."===r||".."===r)return;const o=new Ue.FileInfo(r);switch(o.size=parseInt(t[18],10),o.user=t[16],o.group=t[17],o.hardLinkCount=parseInt(t[15],10),o.rawModifiedAt=t[19]+" "+t[20],o.permissions={user:qe(t[4],t[5],t[6]),group:qe(t[8],t[9],t[10]),world:qe(t[12],t[13],t[14])},t[1].charAt(0)){case"d":o.type=Ue.FileType.Directory;break;case"e":case"l":o.type=Ue.FileType.SymbolicLink;break;case"b":case"c":case"f":case"-":o.type=Ue.FileType.File;break;default:o.type=Ue.FileType.Unknown}if(o.isSymbolicLink){const e=r.indexOf(" -> ");-1!==e&&(o.name=r.substring(0,e),o.link=r.substring(e+4))}return o},We.transformList=function(e){return e};var Be={};Object.defineProperty(Be,"__esModule",{value:!0}),Be.parseMLSxDate=Be.transformList=Be.parseLine=Be.testLine=void 0;const Ke=Fe;function He(e,t){t.size=parseInt(e,10)}const ze={size:He,sizd:He,unique:(e,t)=>{t.uniqueID=e},modify:(e,t)=>{t.modifiedAt=Ve(e),t.rawModifiedAt=t.modifiedAt.toISOString()},type:(e,t)=>{if(e.startsWith("OS.unix=slink"))return t.type=Ke.FileType.SymbolicLink,t.link=e.substr(e.indexOf(":")+1),1;switch(e){case"file":t.type=Ke.FileType.File;break;case"dir":t.type=Ke.FileType.Directory;break;case"OS.unix=symlink":t.type=Ke.FileType.SymbolicLink;break;case"cdir":case"pdir":return 2;default:t.type=Ke.FileType.Unknown}return 1},"unix.mode":(e,t)=>{const r=e.substr(-3);t.permissions={user:parseInt(r[0],10),group:parseInt(r[1],10),world:parseInt(r[2],10)}},"unix.ownername":(e,t)=>{t.user=e},"unix.owner":(e,t)=>{void 0===t.user&&(t.user=e)},get"unix.uid"(){return this["unix.owner"]},"unix.groupname":(e,t)=>{t.group=e},"unix.group":(e,t)=>{void 0===t.group&&(t.group=e)},get"unix.gid"(){return this["unix.group"]}};function Ye(e,t){const r=e.indexOf(t);return[e.substr(0,r),e.substr(r+t.length)]}function Ve(e){return new Date(Date.UTC(+e.slice(0,4),+e.slice(4,6)-1,+e.slice(6,8),+e.slice(8,10),+e.slice(10,12),+e.slice(12,14),+e.slice(15,18)))}Be.testLine=function(e){return/^\S+=\S+;/.test(e)||e.startsWith(" ")},Be.parseLine=function(e){const[t,r]=Ye(e," ");if(""===r||"."===r||".."===r)return;const o=new Ke.FileInfo(r),n=t.split(";");for(const e of n){const[t,r]=Ye(e,"=");if(!r)continue;const n=ze[t.toLowerCase()];if(!n)continue;if(2===n(r,o))return}return o},Be.transformList=function(e){const t=new Map;for(const r of e)r.isSymbolicLink||void 0===r.uniqueID||t.set(r.uniqueID,r);const r=[];for(const o of e){if(o.isSymbolicLink&&void 0!==o.uniqueID&&void 0===o.link){const e=t.get(o.uniqueID);void 0!==e&&(o.link=e.name)}!o.name.includes("/")&&r.push(o)}return r},Be.parseMLSxDate=Ve;var Xe=ve&&ve.__createBinding||(Object.create?function(e,t,r,o){void 0===o&&(o=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,o,n)}:function(e,t,r,o){void 0===o&&(o=r),e[o]=t[r]}),Je=ve&&ve.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),Ze=ve&&ve.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&Xe(t,e,r);return Je(t,e),t};Object.defineProperty(Me,"__esModule",{value:!0}),Me.parseList=void 0;const Qe=[Ze(Le),Ze(We),Ze(Be)];function et(e){return""!==e.trim()}function tt(e){return!e.startsWith("total")}const rt=/\r?\n/;Me.parseList=function(e){const t=e.split(rt).filter(et).filter(tt);if(0===t.length)return[];const r=t[t.length-1],o=(n=r,Qe.find((e=>!0===e.testLine(n))));var n;if(!o)throw new Error("This library only supports MLSD, Unix- or DOS-style directory listing. Your FTP server seems to be using another format. You can see the transmitted listing when setting `client.ftp.verbose = true`. You can then provide a custom parser to `client.parseList`, see the documentation for details.");const s=t.map(o.parseLine).filter((e=>void 0!==e));return o.transformList(s)};var ot={};Object.defineProperty(ot,"__esModule",{value:!0}),ot.ProgressTracker=void 0;function nt(){}ot.ProgressTracker=class{constructor(){this.bytesOverall=0,this.intervalMs=500,this.onStop=nt,this.onHandle=nt}reportTo(e=nt){this.onHandle=e}start(e,t,r){let o=0;this.onStop=function(e,t){const r=setInterval(t,e),o=e=>{clearInterval(r),e&&t(),t=nt};return t(),o}(this.intervalMs,(()=>{const n=e.bytesRead+e.bytesWritten;this.bytesOverall+=n-o,o=n,this.onHandle({name:t,type:r,bytes:n,bytesOverall:this.bytesOverall})}))}stop(){this.onStop(!1)}updateAndStop(){this.onStop(!0)}};var st={};Object.defineProperty(st,"__esModule",{value:!0}),st.StringWriter=void 0;const it=u;class at extends it.Writable{constructor(){super(...arguments),this.buf=Buffer.alloc(0)}_write(e,t,r){e instanceof Buffer?(this.buf=Buffer.concat([this.buf,e]),r(null)):r(new Error("StringWriter expects chunks of type 'Buffer'."))}getText(e){return this.buf.toString(e)}}st.StringWriter=at;var ct={};Object.defineProperty(ct,"__esModule",{value:!0}),ct.ipIsPrivateV4Address=ct.upgradeSocket=ct.describeAddress=ct.describeTLS=void 0;const lt=c;ct.describeTLS=function(e){if(e instanceof lt.TLSSocket){const t=e.getProtocol();return t||"Server socket or disconnected client socket"}return"No encryption"},ct.describeAddress=function(e){return"IPv6"===e.remoteFamily?`[${e.remoteAddress}]:${e.remotePort}`:`${e.remoteAddress}:${e.remotePort}`},ct.upgradeSocket=function(e,t){return new Promise(((r,o)=>{const n=Object.assign({},t,{socket:e}),s=(0,lt.connect)(n,(()=>{!1!==n.rejectUnauthorized&&!s.authorized?o(s.authorizationError):(s.removeAllListeners("error"),r(s))})).once("error",(e=>{o(e)}))}))},ct.ipIsPrivateV4Address=function(e=""){e.startsWith("::ffff:")&&(e=e.substr(7));const t=e.split(".").map((e=>parseInt(e,10)));return 10===t[0]||172===t[0]&&t[1]>=16&&t[1]<=31||192===t[0]&&168===t[1]||"127.0.0.1"===e};var dt={};Object.defineProperty(dt,"__esModule",{value:!0}),dt.downloadTo=dt.uploadFrom=dt.connectForPassiveTransfer=dt.parsePasvResponse=dt.enterPassiveModeIPv4=dt.parseEpsvResponse=dt.enterPassiveModeIPv6=void 0;const ut=ct,ht=u,pt=c,ft=Se;function mt(e){const t=e.match(/[|!]{3}(.+)[|!]/);if(null===t||void 0===t[1])throw new Error(`Can't parse response to 'EPSV': ${e}`);const r=parseInt(t[1],10);if(Number.isNaN(r))throw new Error(`Can't parse response to 'EPSV', port is not a number: ${e}`);return r}function gt(e){const t=e.match(/([-\d]+,[-\d]+,[-\d]+,[-\d]+),([-\d]+),([-\d]+)/);if(null===t||4!==t.length)throw new Error(`Can't parse response to 'PASV': ${e}`);return{host:t[1].replace(/,/g,"."),port:256*(255&parseInt(t[2],10))+(255&parseInt(t[3],10))}}function wt(e,t,r){return new Promise(((o,n)=>{let s=r._newSocket();const i=function(e){e.message="Can't open data connection in passive mode: "+e.message,n(e)},a=function(){s.destroy(),n(new Error(`Timeout when trying to open data connection to ${e}:${t}`))};s.setTimeout(r.timeout),s.on("error",i),s.on("timeout",a),s.connect({port:t,host:e,family:r.ipFamily},(()=>{r.socket instanceof pt.TLSSocket&&(s=(0,pt.connect)(Object.assign({},r.tlsOptions,{socket:s,session:r.socket.getSession()}))),s.removeListener("error",i),s.removeListener("timeout",a),r.dataSocket=s,o()}))}))}dt.enterPassiveModeIPv6=async function(e){const t=await e.request("EPSV"),r=mt(t.message);if(!r)throw new Error("Can't parse EPSV response: "+t.message);const o=e.socket.remoteAddress;if(void 0===o)throw new Error("Control socket is disconnected, can't get remote address.");return await wt(o,r,e),t},dt.parseEpsvResponse=mt,dt.enterPassiveModeIPv4=async function(e){const t=await e.request("PASV"),r=gt(t.message);if(!r)throw new Error("Can't parse PASV response: "+t.message);const o=e.socket.remoteAddress;return(0,ut.ipIsPrivateV4Address)(r.host)&&o&&!(0,ut.ipIsPrivateV4Address)(o)&&(r.host=o),await wt(r.host,r.port,e),t},dt.parsePasvResponse=gt,dt.connectForPassiveTransfer=wt;class yt{constructor(e,t){this.ftp=e,this.progress=t,this.response=void 0,this.dataTransferDone=!1}onDataStart(e,t){if(void 0===this.ftp.dataSocket)throw new Error("Data transfer should start but there is no data connection.");this.ftp.socket.setTimeout(0),this.ftp.dataSocket.setTimeout(this.ftp.timeout),this.progress.start(this.ftp.dataSocket,e,t)}onDataDone(e){this.progress.updateAndStop(),this.ftp.socket.setTimeout(this.ftp.timeout),this.ftp.dataSocket&&this.ftp.dataSocket.setTimeout(0),this.dataTransferDone=!0,this.tryResolve(e)}onControlDone(e,t){this.response=t,this.tryResolve(e)}onError(e,t){this.progress.updateAndStop(),this.ftp.socket.setTimeout(this.ftp.timeout),this.ftp.dataSocket=void 0,e.reject(t)}onUnexpectedRequest(e){const t=new Error(`Unexpected FTP response is requesting an answer: ${e.message}`);this.ftp.closeWithError(t)}tryResolve(e){this.dataTransferDone&&void 0!==this.response&&(this.ftp.dataSocket=void 0,e.resolve(this.response))}}dt.uploadFrom=function(e,t){const r=new yt(t.ftp,t.tracker),o=`${t.command} ${t.remotePath}`;return t.ftp.handle(o,((o,n)=>{if(o instanceof Error)r.onError(n,o);else if(150===o.code||125===o.code){const o=t.ftp.dataSocket;if(!o)return void r.onError(n,new Error("Upload should begin but no data connection is available."));const c=!("getCipher"in o)||void 0!==o.getCipher();s=o,i="secureConnect",a=()=>{t.ftp.log(`Uploading to ${(0,ut.describeAddress)(o)} (${(0,ut.describeTLS)(o)})`),r.onDataStart(t.remotePath,t.type),(0,ht.pipeline)(e,o,(e=>{e?r.onError(n,e):r.onDataDone(n)}))},!0===c?a():s.once(i,(()=>a()))}else(0,ft.positiveCompletion)(o.code)?r.onControlDone(n,o):(0,ft.positiveIntermediate)(o.code)&&r.onUnexpectedRequest(o);var s,i,a}))},dt.downloadTo=function(e,t){if(!t.ftp.dataSocket)throw new Error("Download will be initiated but no data connection is available.");const r=new yt(t.ftp,t.tracker);return t.ftp.handle(t.command,((o,n)=>{if(o instanceof Error)r.onError(n,o);else if(150===o.code||125===o.code){const o=t.ftp.dataSocket;if(!o)return void r.onError(n,new Error("Download should begin but no data connection is available."));t.ftp.log(`Downloading from ${(0,ut.describeAddress)(o)} (${(0,ut.describeTLS)(o)})`),r.onDataStart(t.remotePath,t.type),(0,ht.pipeline)(o,e,(e=>{e?r.onError(n,e):r.onDataDone(n)}))}else 350===o.code?t.ftp.send("RETR "+t.remotePath):(0,ft.positiveCompletion)(o.code)?r.onControlDone(n,o):(0,ft.positiveIntermediate)(o.code)&&r.onUnexpectedRequest(o)}))},Object.defineProperty(Ee,"__esModule",{value:!0}),Ee.Client=void 0;const _t=i,Tt=a,vt=c,bt=l,Et=ke,kt=Me,St=ot,Ot=st,Ct=Be,Dt=ct,It=dt,$t=Se,At=(0,bt.promisify)(_t.readdir),Pt=(0,bt.promisify)(_t.mkdir),Rt=(0,bt.promisify)(_t.stat),Mt=(0,bt.promisify)(_t.open),Lt=(0,bt.promisify)(_t.close),Ft=(0,bt.promisify)(_t.unlink);async function xt(e){try{return await e()}catch(e){return}}Ee.Client=class{constructor(e=3e4){this.availableListCommands=["LIST -a","LIST"],this.ftp=new Et.FTPContext(e),this.prepareTransfer=this._enterFirstCompatibleMode([It.enterPassiveModeIPv6,It.enterPassiveModeIPv4]),this.parseList=kt.parseList,this._progressTracker=new St.ProgressTracker}close(){this.ftp.close(),this._progressTracker.stop()}get closed(){return this.ftp.closed}connect(e="localhost",t=21){return this.ftp.reset(),this.ftp.socket.connect({host:e,port:t,family:this.ftp.ipFamily},(()=>this.ftp.log(`Connected to ${(0,Dt.describeAddress)(this.ftp.socket)} (${(0,Dt.describeTLS)(this.ftp.socket)})`))),this._handleConnectResponse()}connectImplicitTLS(e="localhost",t=21,r={}){return this.ftp.reset(),this.ftp.socket=(0,vt.connect)(t,e,r,(()=>this.ftp.log(`Connected to ${(0,Dt.describeAddress)(this.ftp.socket)} (${(0,Dt.describeTLS)(this.ftp.socket)})`))),this.ftp.tlsOptions=r,this._handleConnectResponse()}_handleConnectResponse(){return this.ftp.handle(void 0,((e,t)=>{e instanceof Error?t.reject(e):(0,$t.positiveCompletion)(e.code)?t.resolve(e):t.reject(new Et.FTPError(e))}))}send(e,t=!1){return t?(this.ftp.log("Deprecated call using send(command, flag) with boolean flag to ignore errors. Use sendIgnoringError(command)."),this.sendIgnoringError(e)):this.ftp.request(e)}sendIgnoringError(e){return this.ftp.handle(e,((e,t)=>{e instanceof Et.FTPError?t.resolve({code:e.code,message:e.message}):e instanceof Error?t.reject(e):t.resolve(e)}))}async useTLS(e={},t="AUTH TLS"){const r=await this.send(t);return this.ftp.socket=await(0,Dt.upgradeSocket)(this.ftp.socket,e),this.ftp.tlsOptions=e,this.ftp.log(`Control socket is using: ${(0,Dt.describeTLS)(this.ftp.socket)}`),r}login(e="anonymous",t="guest"){return this.ftp.log(`Login security: ${(0,Dt.describeTLS)(this.ftp.socket)}`),this.ftp.handle("USER "+e,((e,r)=>{e instanceof Error?r.reject(e):(0,$t.positiveCompletion)(e.code)?r.resolve(e):331===e.code?this.ftp.send("PASS "+t):r.reject(new Et.FTPError(e))}))}async useDefaultSettings(){const e=(await this.features()).has("MLST");this.availableListCommands=e?["MLSD","LIST -a","LIST"]:["LIST -a","LIST"],await this.send("TYPE I"),await this.sendIgnoringError("STRU F"),await this.sendIgnoringError("OPTS UTF8 ON"),e&&await this.sendIgnoringError("OPTS MLST type;size;modify;unique;unix.mode;unix.owner;unix.group;unix.ownername;unix.groupname;"),this.ftp.hasTLS&&(await this.sendIgnoringError("PBSZ 0"),await this.sendIgnoringError("PROT P"))}async access(e={}){var t,r;const o=!0===e.secure;let n;if(n="implicit"===e.secure?await this.connectImplicitTLS(e.host,e.port,e.secureOptions):await this.connect(e.host,e.port),o){const o=null!==(t=e.secureOptions)&&void 0!==t?t:{};o.host=null!==(r=o.host)&&void 0!==r?r:e.host,await this.useTLS(o)}return await this.sendIgnoringError("OPTS UTF8 ON"),await this.login(e.user,e.password),await this.useDefaultSettings(),n}async pwd(){const e=await this.send("PWD"),t=e.message.match(/"(.+)"/);if(null===t||void 0===t[1])throw new Error(`Can't parse response to command 'PWD': ${e.message}`);return t[1]}async features(){const e=await this.sendIgnoringError("FEAT"),t=new Map;return e.code<400&&(0,$t.isMultiline)(e.message)&&e.message.split("\n").slice(1,-1).forEach((e=>{const r=e.trim().split(" ");t.set(r[0],r[1]||"")})),t}async cd(e){const t=await this.protectWhitespace(e);return this.send("CWD "+t)}async cdup(){return this.send("CDUP")}async lastMod(e){const t=await this.protectWhitespace(e),r=(await this.send(`MDTM ${t}`)).message.slice(4);return(0,Ct.parseMLSxDate)(r)}async size(e){const t=`SIZE ${await this.protectWhitespace(e)}`,r=await this.send(t),o=parseInt(r.message.slice(4),10);if(Number.isNaN(o))throw new Error(`Can't parse response to command '${t}' as a numerical value: ${r.message}`);return o}async rename(e,t){const r=await this.protectWhitespace(e),o=await this.protectWhitespace(t);return await this.send("RNFR "+r),this.send("RNTO "+o)}async remove(e,t=!1){const r=await this.protectWhitespace(e);return t?this.sendIgnoringError(`DELE ${r}`):this.send(`DELE ${r}`)}trackProgress(e){this._progressTracker.bytesOverall=0,this._progressTracker.reportTo(e)}async uploadFrom(e,t,r={}){return this._uploadWithCommand(e,t,"STOR",r)}async appendFrom(e,t,r={}){return this._uploadWithCommand(e,t,"APPE",r)}async _uploadWithCommand(e,t,r,o){return"string"==typeof e?this._uploadLocalFile(e,t,r,o):this._uploadFromStream(e,t,r)}async _uploadLocalFile(e,t,r,o){const n=await Mt(e,"r"),s=(0,_t.createReadStream)("",{fd:n,start:o.localStart,end:o.localEndInclusive,autoClose:!1});try{return await this._uploadFromStream(s,t,r)}finally{await xt((()=>Lt(n)))}}async _uploadFromStream(e,t,r){const o=e=>this.ftp.closeWithError(e);e.once("error",o);try{const o=await this.protectWhitespace(t);return await this.prepareTransfer(this.ftp),await(0,It.uploadFrom)(e,{ftp:this.ftp,tracker:this._progressTracker,command:r,remotePath:o,type:"upload"})}finally{e.removeListener("error",o)}}async downloadTo(e,t,r=0){return"string"==typeof e?this._downloadToFile(e,t,r):this._downloadToStream(e,t,r)}async _downloadToFile(e,t,r){const o=r>0,n=o?"r+":"w",s=await Mt(e,n),i=(0,_t.createWriteStream)("",{fd:s,start:r,autoClose:!1});try{return await this._downloadToStream(i,t,r)}catch(t){const r=await xt((()=>Rt(e))),n=r&&r.size>0;throw!o&&!n&&await xt((()=>Ft(e))),t}finally{await xt((()=>Lt(s)))}}async _downloadToStream(e,t,r){const o=e=>this.ftp.closeWithError(e);e.once("error",o);try{const o=await this.protectWhitespace(t);return await this.prepareTransfer(this.ftp),await(0,It.downloadTo)(e,{ftp:this.ftp,tracker:this._progressTracker,command:r>0?`REST ${r}`:`RETR ${o}`,remotePath:o,type:"download"})}finally{e.removeListener("error",o),e.end()}}async list(e=""){const t=await this.protectWhitespace(e);let r;for(const e of this.availableListCommands){const o=""===t?e:`${e} ${t}`;await this.prepareTransfer(this.ftp);try{const t=await this._requestListWithCommand(o);return this.availableListCommands=[e],t}catch(e){if(!(e instanceof Et.FTPError))throw e;r=e}}throw r}async _requestListWithCommand(e){const t=new Ot.StringWriter;await(0,It.downloadTo)(t,{ftp:this.ftp,tracker:this._progressTracker,command:e,remotePath:"",type:"list"});const r=t.getText(this.ftp.encoding);return this.ftp.log(r),this.parseList(r)}async removeDir(e){return this._exitAtCurrentDirectory((async()=>{await this.cd(e);const t=await this.pwd();await this.clearWorkingDir();"/"===t||(await this.cdup(),await this.removeEmptyDir(t))}))}async clearWorkingDir(){for(const e of await this.list())e.isDirectory?(await this.cd(e.name),await this.clearWorkingDir(),await this.cdup(),await this.removeEmptyDir(e.name)):await this.remove(e.name)}async uploadFromDir(e,t){return this._exitAtCurrentDirectory((async()=>(t&&await this.ensureDir(t),await this._uploadToWorkingDir(e))))}async _uploadToWorkingDir(e){const t=await At(e);for(const r of t){const t=(0,Tt.join)(e,r),o=await Rt(t);o.isFile()?await this.uploadFrom(t,r):o.isDirectory()&&(await this._openDir(r),await this._uploadToWorkingDir(t),await this.cdup())}}async downloadToDir(e,t){return this._exitAtCurrentDirectory((async()=>(t&&await this.cd(t),await this._downloadFromWorkingDir(e))))}async _downloadFromWorkingDir(e){await async function(e){try{await Rt(e)}catch(t){await Pt(e,{recursive:!0})}}(e);for(const t of await this.list()){const r=(0,Tt.join)(e,t.name);t.isDirectory?(await this.cd(t.name),await this._downloadFromWorkingDir(r),await this.cdup()):t.isFile&&await this.downloadTo(r,t.name)}}async ensureDir(e){e.startsWith("/")&&await this.cd("/");const t=e.split("/").filter((e=>""!==e));for(const e of t)await this._openDir(e)}async _openDir(e){await this.sendIgnoringError("MKD "+e),await this.cd(e)}async removeEmptyDir(e){const t=await this.protectWhitespace(e);return this.send(`RMD ${t}`)}async protectWhitespace(e){if(!e.startsWith(" "))return e;const t=await this.pwd();return(t.endsWith("/")?t:t+"/")+e}async _exitAtCurrentDirectory(e){const t=await this.pwd();try{return await e()}finally{this.closed||await xt((()=>this.cd(t)))}}_enterFirstCompatibleMode(e){return async t=>{let r;t.log("Trying to find optimal transfer strategy...");for(const o of e)try{const e=await o(t);return t.log("Optimal transfer strategy found."),this.prepareTransfer=o,e}catch(e){r=e}throw new Error(`None of the available transfer strategies work. Last error response was '${r}'.`)}}async upload(e,t,r={}){return this.ftp.log("Warning: upload() has been deprecated, use uploadFrom()."),this.uploadFrom(e,t,r)}async append(e,t,r={}){return this.ftp.log("Warning: append() has been deprecated, use appendFrom()."),this.appendFrom(e,t,r)}async download(e,t,r=0){return this.ftp.log("Warning: download() has been deprecated, use downloadTo()."),this.downloadTo(e,t,r)}async uploadDir(e,t){return this.ftp.log("Warning: uploadDir() has been deprecated, use uploadFromDir()."),this.uploadFromDir(e,t)}async downloadDir(e){return this.ftp.log("Warning: downloadDir() has been deprecated, use downloadToDir()."),this.downloadToDir(e)}};var jt={};Object.defineProperty(jt,"__esModule",{value:!0}),function(e){var t=ve&&ve.__createBinding||(Object.create?function(e,t,r,o){void 0===o&&(o=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,o,n)}:function(e,t,r,o){void 0===o&&(o=r),e[o]=t[r]}),r=ve&&ve.__exportStar||function(e,r){for(var o in e)"default"===o||Object.prototype.hasOwnProperty.call(r,o)||t(r,e,o)};Object.defineProperty(e,"__esModule",{value:!0}),e.enterPassiveModeIPv6=e.enterPassiveModeIPv4=void 0,r(Ee,e),r(ke,e),r(Fe,e),r(Me,e),r(jt,e);var o=dt;Object.defineProperty(e,"enterPassiveModeIPv4",{enumerable:!0,get:function(){return o.enterPassiveModeIPv4}}),Object.defineProperty(e,"enterPassiveModeIPv6",{enumerable:!0,get:function(){return o.enterPassiveModeIPv6}})}(be);const Nt=async()=>{const[e,t]=await Te();if(!e)return[!1,t];const r=new be.Client,{user:o,password:n,port:s,host:i,secure:a}=t.ftp;return new Promise((async e=>{try{await r.access({host:i,password:n,user:o,port:"string"==typeof s&&"default"===s?void 0:s,secure:a}),e([!0,r])}catch(t){r.close(),e([!1,`FTP error: ${t?.code}`])}}))},Wt=e=>{if(!e.peek())return void console.log(`\n${Object.values(B).join("\n\n")}\n`);const t=e.peek();Object.keys(B).find((e=>e==t))?.length?console.log(`\n${B[t]}\n`):(console.error(N.red(`\nCommand '${t}' doesn't exist.`)),console.log(U("Type 'brifka help' to view documentation of all commands.","Help")))},Ut=e=>{K(J),K(Q),K(Z),(async e=>{const t=n.normalize(e),r=n.parse(t),s=[...r.dir.split(n.sep),r.name].filter((e=>e.length>0));for(let e=0;e<s.length;e++)try{await o.mkdir(n.resolve(process.cwd(),...s.slice(0,e+1)))}catch{}})(ee);K(re,JSON.stringify({ftp:{host:"localhost",port:"default",user:"anonymus",password:"anonymus@",directory:""}},void 0,2)),K(".brignore",re),console.log(N.green(`\n${V.INIT_SUCCESS}\n`))},Gt=async e=>{const r=e.next();if(!r||r.length<=0)return void console.error(N.red(`\n${V.TRACK_NO_ARGUMENT}\n`));const s=n.resolve(process.cwd(),r);let i;try{i=await o.stat(s)}catch{return void console.error(N.red(`\nFile or directory '${r}' doesn't exist.\n`))}let a=new Set;try{const[e,t]=await z(".brignore",ce);if(!e)throw new Error;a=new Set([...t,...le])}catch{a=new Set(le)}const c=".brifka/mem/tracked",[l,d]=await z(c,ne);if(!l)return void console.error(N.red(`\n${V.TRACKED_FILE_NOT_EXISTING}\n`));const u=new Set(d);if(i.isDirectory()){const e=new Set;await Y(s,e,a);const o=new Set(Array.from(e).filter((e=>!u.has(e))));await H(c,oe(Array.from(o))+t.EOL),console.log(`\n${V.TRACKED_PATHS_ADDED(o.size,r)}\n`)}else if(i.isFile()){const e=n.relative(process.cwd(),s);if(u.has(e))return void console.error(N.red(`\n${V.TRACKED_PATH_ALREADY_TRACKED(r)}\n`));await H(c,oe([e])+t.EOL),console.log(N.green(`\n${V.TRACKED_PATH_ADDED(r)}\n`))}},qt=async e=>{const t=e.next();if(!t||t.length<=0)return void console.error(N.red(`\n${V.UNTRACK_NO_ARGUMENT}\n`));const[r,s]=await z(Q,ne);if(!r)return void console.error(N.red(`\n${V.TRACKED_FILE_NOT_EXISTING}\n`));const i=n.normalize(t),a=n.resolve(t),c=new Set(s);let l;try{l=await o.stat(a)}catch{return void console.log(N.red(`\n${V.TRACKED_DOES_NOT_EXIST(t)}\n`))}if(l.isFile())c.delete(i)?console.log(`\n${V.TRACKED_REMOVED_FILE}\n`):console.log(N.red(`\n${V.TRACKED_FILE_WAS_NOT_TRACKED(t)}\n`));else if(l.isDirectory()){const e=new Set;await Y(a,e);let r=0;for(const t of e)c.delete(t)&&r++;console.log(`\n${V.TRACKED_PATHS_REMOVED(r,t)}\n`)}await K(Q,oe(Array.from(c)))},Bt=async e=>{const r=e.next();if(!r||r.length<=0)return void console.error(N.red(`\n${V.COMMIT_NO_ARGUMENT}\n`));const[o,n]=await z(Q,ne);if(!o||n.length<=0)return void console.error(N.red(`\n${V.TRACKED_EMPTY}\n`));if(!o)return void console.error(N.red(`\n${V.TRACKED_FILE_NOT_EXISTING}\n`));const i=[],a=s.randomBytes(32).toString("hex");await H(J,`${se([{title:r,hash:a,timestamp:Date.now()}])}${t.EOL}`);for(const e of n){const[t,r]=await z(e);if(!t)continue;const o=s.createHash("sha256").update(r).digest("hex");await de(e,o),i.push({path:e,hash:o})}var c;await K(te(a),(c=i,c.map((({path:e,hash:t})=>`${e.length}${e}${t}`)).join(t.EOL))),await K(Z,a),console.log(N.green(`\n${V.COMMIT_SUCCESS}\n`))},Kt=async e=>{const[t,r]=await z(J,ie);if(!t)return;if(r.length<=0)return void console.error(N.red(`\n${V.COMMITS_EMPTY}\n`));const[,o]=await z(Z);console.log(`\n${r.reverse().map((({title:e,hash:t,timestamp:r})=>`${N.yellow("commit: "+t)}${o&&o===t?N.blue(" <- HEAD"):""}\nDate: ${new Date(r).toLocaleString()}\n\n\t${e}`)).join("\n\n")}\n`)},Ht=async e=>{const t=e.next();if(!t||t.length<=0)return void console.error(N.red(`\n${V.CHANGE_NO_ARGUMENT}\n`));const[r,o]=await z(J,ie);if(!r)return;const n=o.filter((({hash:e})=>t==e))[0];if(!n)return void console.error(N.red(`\n${V.COMMIT_DOES_NOT_EXIST(t)}\n`));he(process.cwd());const[s,i]=await z(te(n.hash),ae);if(!s)return;const a=[];let c=0;for(const{hash:e,path:t}of i){const[r,o]=await z(te(e));r?(await K(t,o),c++):a.push(t)}await K(Z,t),a.length>0&&console.error(`\n${N.red(a.length)} files failed to load from repository.`),console.log(`\n${N.green(c)} files successfully loaded from repository.\n`)},zt=async e=>{const t=e.next(),[r,o]=await z(".brifka/mem/tracked",ne);if(!r)return;const n=new Set(o);let s=new Set;try{const[e,t]=await z(".brignore",ce);if(!e)throw new Error;s=new Set([...t,...pe])}catch{}const i=new Set;if(await Y(process.cwd(),i,s),"full"===t)return void((e,t)=>{console.log(N.green("\ntracked\n======="));for(const t of e)console.log(N.green(t));console.log(N.red("\nnot tracked\n==========="));for(const r of t)e.has(r)||console.log(N.red(r));console.log()})(n,i);let a=0;for(const e of i)n.has(e)||a++;console.log(`\n${N.green(n.size)} files are in tracked stage.\n${N.red(a)} files aren't in tracked stage.\n`)},Yt=async e=>{const t=".brifka/mem/commits",[r,o]=await z(t,ie);if(!r)return void console.error(N.red(`\n${V.COMMIT_NOT_EXISTING}\n`));const n=o.pop();n?(await K(t,se(o)),console.error(`\n${N.green(V.COMMIT_REMOVE_SUCCESS)}\n\n${V.COMMIT_INFO(n.hash,n.timestamp,n.title)}\n`)):console.error(N.red(`\n${V.COMMITS_EMPTY}\n`))},Vt=e=>{const t=e.next();if(!t||t.length<=0)console.error(N.red("\nFtp command requires pull | push | list argument.\n"));else switch(t){case"pull":(async()=>{const[e,t]=await Te();if(!e)return void console.error(N.red(`\n${t}\n`));t.ftp;const[r,o]=await Nt();r||console.error(N.red(`\n${o}\n`))})();break;case"push":(async()=>{await Te()||console.error(N.red(`\n${V.CONFIG_NOT_EXISTING}\n`))})();break;case"list":(async e=>{let t=e.next();!1===t&&(t=".");const[r,o]=await Te();if(!r)return void console.error(N.red(`\n${o}\n`));const{directory:s}=o.ftp,[i,a]=await Nt();if(i){try{const e=await a.list(n.join(s,t).replace("\\","/"));console.log();for(const r of e){const e=r.isDirectory?N.cyan("D"):r.isFile?N.yellow("F"):" ";console.log(`${e} ${n.join(t,r.name)}`)}console.log()}catch(e){console.log(e,"err")}a.close()}else console.error(N.red(`\n${a}\n`))})(e);break;default:console.error(N.red(`\n'${t}' is not valid argument. Expected pull | push | list argument.\n`))}};(async()=>{const e=new W(process.argv.slice(2)),t=e.peek();let r=!1;try{if(!(await o.stat(n.resolve(process.cwd(),".brifka"))).isDirectory())throw new Error;r=!0}catch{}if(!r&&(!t||"init"!=t&&"help"!=t))return console.log(N.red("\nBrifka repository is not initialized.")),void console.log(U("Type 'brifka init' to initialize repository.","Help"));(e=>{const t=e.next();switch(t){case"help":Wt(e);break;case"init":Ut(e);break;case"track":Gt(e);break;case"untrack":qt(e);break;case"commit":Bt(e);break;case"commits":Kt(e);break;case"change":Ht(e);break;case"log":zt(e);break;case"uncommit":Yt(e);break;case"ftp":Vt(e);break;default:console.error(N.red(`\nCommand '${t}' doesn't exist.`)),console.log(U("To get documentation of all commands type 'brifka help' or 'brifka help <command_name>' to get documentation of specific command.","Help"))}})(e)})();
