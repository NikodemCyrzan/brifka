"use strict";var e=require("node:process"),t=require("node:os"),r=require("node:tty"),o=require("node:fs/promises"),n=require("node:path"),s=require("node:crypto"),i=require("fs"),a=require("path"),c=require("tls"),l=require("util"),d=require("net"),u=require("stream");const h=(e=0)=>t=>`[${t+e}m`,p=(e=0)=>t=>`[${38+e};5;${t}m`,f=(e=0)=>(t,r,o)=>`[${38+e};2;${t};${r};${o}m`,m={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],overline:[53,55],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],blackBright:[90,39],gray:[90,39],grey:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgGray:[100,49],bgGrey:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};Object.keys(m.modifier);Object.keys(m.color),Object.keys(m.bgColor);const g=function(){const e=new Map;for(const[t,r]of Object.entries(m)){for(const[t,o]of Object.entries(r))m[t]={open:`[${o[0]}m`,close:`[${o[1]}m`},r[t]=m[t],e.set(o[0],o[1]);Object.defineProperty(m,t,{value:r,enumerable:!1})}return Object.defineProperty(m,"codes",{value:e,enumerable:!1}),m.color.close="[39m",m.bgColor.close="[49m",m.color.ansi=h(),m.color.ansi256=p(),m.color.ansi16m=f(),m.bgColor.ansi=h(10),m.bgColor.ansi256=p(10),m.bgColor.ansi16m=f(10),Object.defineProperties(m,{rgbToAnsi256:{value:(e,t,r)=>e===t&&t===r?e<8?16:e>248?231:Math.round((e-8)/247*24)+232:16+36*Math.round(e/255*5)+6*Math.round(t/255*5)+Math.round(r/255*5),enumerable:!1},hexToRgb:{value(e){const t=/[a-f\d]{6}|[a-f\d]{3}/i.exec(e.toString(16));if(!t)return[0,0,0];let[r]=t;3===r.length&&(r=[...r].map((e=>e+e)).join(""));const o=Number.parseInt(r,16);return[o>>16&255,o>>8&255,255&o]},enumerable:!1},hexToAnsi256:{value:e=>m.rgbToAnsi256(...m.hexToRgb(e)),enumerable:!1},ansi256ToAnsi:{value(e){if(e<8)return 30+e;if(e<16)return e-8+90;let t,r,o;if(e>=232)t=(10*(e-232)+8)/255,r=t,o=t;else{const n=(e-=16)%36;t=Math.floor(e/36)/5,r=Math.floor(n/6)/5,o=n%6/5}const n=2*Math.max(t,r,o);if(0===n)return 30;let s=30+(Math.round(o)<<2|Math.round(r)<<1|Math.round(t));return 2===n&&(s+=60),s},enumerable:!1},rgbToAnsi:{value:(e,t,r)=>m.ansi256ToAnsi(m.rgbToAnsi256(e,t,r)),enumerable:!1},hexToAnsi:{value:e=>m.ansi256ToAnsi(m.hexToAnsi256(e)),enumerable:!1}}),m}();function w(t,r=(globalThis.Deno?globalThis.Deno.args:e.argv)){const o=t.startsWith("-")?"":1===t.length?"-":"--",n=r.indexOf(o+t),s=r.indexOf("--");return-1!==n&&(-1===s||n<s)}const{env:y}=e;let v;function b(r,{streamIsTTY:o,sniffFlags:n=!0}={}){const s=function(){if("FORCE_COLOR"in y)return"true"===y.FORCE_COLOR?1:"false"===y.FORCE_COLOR?0:0===y.FORCE_COLOR.length?1:Math.min(Number.parseInt(y.FORCE_COLOR,10),3)}();void 0!==s&&(v=s);const i=n?v:s;if(0===i)return 0;if(n){if(w("color=16m")||w("color=full")||w("color=truecolor"))return 3;if(w("color=256"))return 2}if("TF_BUILD"in y&&"AGENT_NAME"in y)return 1;if(r&&!o&&void 0===i)return 0;const a=i||0;if("dumb"===y.TERM)return a;if("win32"===e.platform){const e=t.release().split(".");return Number(e[0])>=10&&Number(e[2])>=10586?Number(e[2])>=14931?3:2:1}if("CI"in y)return"GITHUB_ACTIONS"in y||"GITEA_ACTIONS"in y?3:["TRAVIS","CIRCLECI","APPVEYOR","GITLAB_CI","BUILDKITE","DRONE"].some((e=>e in y))||"codeship"===y.CI_NAME?1:a;if("TEAMCITY_VERSION"in y)return/^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(y.TEAMCITY_VERSION)?1:0;if("truecolor"===y.COLORTERM)return 3;if("xterm-kitty"===y.TERM)return 3;if("TERM_PROGRAM"in y){const e=Number.parseInt((y.TERM_PROGRAM_VERSION||"").split(".")[0],10);switch(y.TERM_PROGRAM){case"iTerm.app":return e>=3?3:2;case"Apple_Terminal":return 2}}return/-256(color)?$/i.test(y.TERM)?2:/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(y.TERM)||"COLORTERM"in y?1:a}function k(e,t={}){return function(e){return 0!==e&&{level:e,hasBasic:!0,has256:e>=2,has16m:e>=3}}(b(e,{streamIsTTY:e&&e.isTTY,...t}))}w("no-color")||w("no-colors")||w("color=false")||w("color=never")?v=0:(w("color")||w("colors")||w("color=true")||w("color=always"))&&(v=1);const T={stdout:k({isTTY:r.isatty(1)}),stderr:k({isTTY:r.isatty(2)})};function S(e,t,r){let o=e.indexOf(t);if(-1===o)return e;const n=t.length;let s=0,i="";do{i+=e.slice(s,o)+t+r,s=o+n,o=e.indexOf(t,s)}while(-1!==o);return i+=e.slice(s),i}const{stdout:_,stderr:E}=T,$=Symbol("GENERATOR"),P=Symbol("STYLER"),O=Symbol("IS_EMPTY"),L=["ansi","ansi","ansi256","ansi16m"],D=Object.create(null),C=e=>{const t=(...e)=>e.join(" ");return((e,t={})=>{if(t.level&&!(Number.isInteger(t.level)&&t.level>=0&&t.level<=3))throw new Error("The `level` option should be an integer from 0 to 3");const r=_?_.level:0;e.level=void 0===t.level?r:t.level})(t,e),Object.setPrototypeOf(t,I.prototype),t};function I(e){return C(e)}Object.setPrototypeOf(I.prototype,Function.prototype);for(const[e,t]of Object.entries(g))D[e]={get(){const r=M(this,R(t.open,t.close,this[P]),this[O]);return Object.defineProperty(this,e,{value:r}),r}};D.visible={get(){const e=M(this,this[P],!0);return Object.defineProperty(this,"visible",{value:e}),e}};const x=(e,t,r,...o)=>"rgb"===e?"ansi16m"===t?g[r].ansi16m(...o):"ansi256"===t?g[r].ansi256(g.rgbToAnsi256(...o)):g[r].ansi(g.rgbToAnsi(...o)):"hex"===e?x("rgb",t,r,...g.hexToRgb(...o)):g[r][e](...o),F=["rgb","hex","ansi256"];for(const e of F){D[e]={get(){const{level:t}=this;return function(...r){const o=R(x(e,L[t],"color",...r),g.color.close,this[P]);return M(this,o,this[O])}}};D["bg"+e[0].toUpperCase()+e.slice(1)]={get(){const{level:t}=this;return function(...r){const o=R(x(e,L[t],"bgColor",...r),g.bgColor.close,this[P]);return M(this,o,this[O])}}}}const A=Object.defineProperties((()=>{}),{...D,level:{enumerable:!0,get(){return this[$].level},set(e){this[$].level=e}}}),R=(e,t,r)=>{let o,n;return void 0===r?(o=e,n=t):(o=r.openAll+e,n=t+r.closeAll),{open:e,close:t,openAll:o,closeAll:n,parent:r}},M=(e,t,r)=>{const o=(...e)=>j(o,1===e.length?""+e[0]:e.join(" "));return Object.setPrototypeOf(o,A),o[$]=e,o[P]=t,o[O]=r,o},j=(e,t)=>{if(e.level<=0||!t)return e[O]?"":t;let r=e[P];if(void 0===r)return t;const{openAll:o,closeAll:n}=r;if(t.includes(""))for(;void 0!==r;)t=S(t,r.close,r.open),r=r.parent;const s=t.indexOf("\n");return-1!==s&&(t=function(e,t,r,o){let n=0,s="";do{const i="\r"===e[o-1];s+=e.slice(n,i?o-1:o)+t+(i?"\r\n":"\n")+r,n=o+1,o=e.indexOf("\n",n)}while(-1!==o);return s+=e.slice(n),s}(t,n,o,s)),o+t+n};Object.defineProperties(I.prototype,D);const W=I();I({level:E?E.level:0});class N{args;index=0;constructor(e){this.args=e}next(){return!(this.index>=this.args.length)&&this.args[this.index++]}prev(){return!(this.index-1<0)&&this.args[--this.index]}peek(){return!(this.index>=this.args.length)&&this.args[this.index]}}const U=(e,t="")=>{const r=[],o=Math.min(process.stdout.columns,45),n=e.split(" ");r.push(`â•­â•´${t}â•¶${Array(o-5-t.length).fill("â”€").join("")}â”€â•®`);let s=[];for(let e=0;e<n.length;e++)if([...s,n[e]].join(" ").length<o-2)s.push(n[e]);else{const t=s.join(" ");r.push(`â”‚${t}${Array(o-2-t.length).fill(" ").join("")}â”‚`),s=[],e--}return s.length>0&&r.push(`â”‚${s.join(" ")}${Array(o-2-s.join(" ").length).fill(" ").join("")}â”‚`),r.push(`â•°${Array(o-2).fill("â”€").join("")}â•¯`),`\n${r.join("\n")}\n`},q=W.yellow,B=W.blue,z={init:`${B("init")}\n\n\tCreates new brifka repository in current working path.`,log:`${B("log\nlog full")}\n\n\tDisplays informations about not tracked and tracked files.\n\t${q("full")} - displays more informations.`,track:`${B("track <directory_path> | <file_path>")}\n\n\tAdds files to the tracked stage.\n\t${q("<directory_path>")} - all files and directories in that directory will be tracked.\n\t${q("<file_path>")} - file will be tracked.`,untrack:`${B("untrack <directory_path> | <file_path> | .")}\n\n\tRemoves files from tracked stage.\n\t${q("<directory_path>")} - all files and directories in that directory will be untracked.\n\t${q("<file_path>")} - file will be untracked.\n\t${q(".")} - all files  will be untracked.`,commit:`${B("commit <commit_name>")}\n\n\tAdds new commit to the repository.\n\t${q("<commit_name>")} - name of new commit.`,uncommit:`${B("uncommit")}\n\n\tRemoves last commit from the repository.`,commits:`${B("commits")}\n${B("commits <limit>")}\n\n\tDisplays commits.\n\t${q("<limit>")} - displays only last x commits.`,change:`${B("change <commit_hash>")}\n\n\tChanges commit that is currently loaded.\n\t${q("<commit_hash>")} - hash of commit which you want to load.`,push:`${B("push")}\n\n\tSends repository to the ftp server specified in 'brifka.config.json'.`,pull:`${B("pull")}\n\n\tDownloads repository from ftp server specified in 'brifka.config.json'.`},H=async(e,t="")=>{const r=n.normalize(e),s=n.parse(r).dir.split(n.sep).filter((e=>e.length>0));e=n.resolve(process.cwd(),r);for(let e=0;e<s.length;e++)try{await o.mkdir(n.resolve(process.cwd(),...s.slice(0,e+1)))}catch{}await o.writeFile(e,t)},V=async(e,t)=>{const r=n.normalize(e),s=n.parse(r).dir.split(n.sep).filter((e=>e.length>0));e=n.resolve(process.cwd(),r);for(let e=0;e<s.length;e++)try{await o.mkdir(n.resolve(process.cwd(),...s.slice(0,e+1)))}catch{}await o.appendFile(e,t)},Y=async e=>{e=n.resolve(process.cwd(),e);try{return await o.readFile(e,{encoding:"utf8"})}catch{return!1}},G=async(e,t,r)=>{const s=await o.readdir(e);for(const i of s)try{const s=n.resolve(e,i),a=await o.stat(s);if(r&&r.has(n.relative(process.cwd(),s)))continue;a.isDirectory()?await G(s,t,r):a.isFile()&&t.add(n.relative(process.cwd(),s))}catch{}},K=e=>e.join(t.EOL),J=e=>e.split(t.EOL).filter((e=>e.length>0)),Z=e=>e.map((({title:e,hash:t,timestamp:r})=>{const o=r.toString();return`${e.length}${e}${o.length}${o}${t}`})).join(t.EOL),Q=e=>{const r=e.split(t.EOL),o=[];try{r.forEach((e=>{if(e.length<=0)return;let t=0,r="";for(;""!=e[t]&&t<e.length;t++)r+=e[t];if(++t>=e.length)throw new Error;let n="",s=t;for(;t<e.length&&t<s+Number(r);t++)n+=e[t];if(""!=e[t])throw new Error;if(++t>=e.length)throw new Error;let i="";for(;""!=e[t]&&t<e.length;t++)i+=e[t];if(++t>=e.length)throw new Error;let a="";for(s=t;t<e.length&&t<s+Number(i);t++)a+=e[t];if(++t>=e.length)throw new Error;let c="";for(;t<e.length;t++)c+=e[t];o.push({title:n,hash:c,timestamp:Number(a)})}))}catch{return console.error(W.red("\nRepository memory corrupted :/\n")),[]}return o},X=e=>e.split(t.EOL),ee=[".brifka"],te=async(e,t)=>{const r=`.brifka/rep/${t.slice(0,8)}`,o=await Y(e);("boolean"!=typeof o||o)&&await H(r,o)},re=new Set([".brifka","brifka.config.json"]),oe=async e=>{const t=await o.readdir(e);let r=0;for(const s of t){const t=`${e}/${s}`,i=await o.stat(t);if(re.has(n.relative(process.cwd(),t)))i.isFile()&&r++;else if(i.isFile())await o.unlink(t);else{await oe(t)<=0&&await o.rmdir(t)}}return r},ne=[".brifka","brifka.config.json"],se=[];let ie=!0,ae=null;const ce=()=>{se.forEach((e=>e(ae)))};(async()=>{const e=await Y("brifka.config.json");if("boolean"==typeof e&&!e)return ie=!1,void ce();try{ae=JSON.parse(e)}catch{}ie=!1,ce()})();const le=async()=>ie?new Promise((e=>se.push(e))):ae;var de="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},ue={},he={},pe={},fe={};Object.defineProperty(fe,"__esModule",{value:!0}),fe.positiveIntermediate=fe.positiveCompletion=fe.isMultiline=fe.isSingleLine=fe.parseControlResponse=void 0;function me(e){return/^\d\d\d(?:$| )/.test(e)}function ge(e){return/^\d\d\d-/.test(e)}function we(e){return""!==e.trim()}fe.parseControlResponse=function(e){const t=e.split(/\r?\n/).filter(we),r=[];let o,n=0;for(let e=0;e<t.length;e++){const s=t[e];if(o)o.test(s)&&(o=void 0,r.push(t.slice(n,e+1).join("\n")));else if(ge(s)){const t=s.substr(0,3);o=new RegExp(`^${t}(?:$| )`),n=e}else me(s)&&r.push(s)}return{messages:r,rest:o?t.slice(n).join("\n")+"\n":""}},fe.isSingleLine=me,fe.isMultiline=ge,fe.positiveCompletion=function(e){return e>=200&&e<300},fe.positiveIntermediate=function(e){return e>=300&&e<400},Object.defineProperty(pe,"__esModule",{value:!0}),pe.FTPContext=pe.FTPError=void 0;const ye=d,ve=fe;class be extends Error{constructor(e){super(e.message),this.name=this.constructor.name,this.code=e.code}}function ke(){}pe.FTPError=be;pe.FTPContext=class{constructor(e=0,t="utf8"){this.timeout=e,this.verbose=!1,this.ipFamily=void 0,this.tlsOptions={},this._partialResponse="",this._encoding=t,this._socket=this.socket=this._newSocket(),this._dataSocket=void 0}close(){const e=this._task?"User closed client during task":"User closed client",t=new Error(e);this.closeWithError(t)}closeWithError(e){this._closingError||(this._closingError=e,this._closeControlSocket(),this._closeSocket(this._dataSocket),this._passToHandler(e),this._stopTrackingTask())}get closed(){return void 0===this.socket.remoteAddress||void 0!==this._closingError}reset(){this.socket=this._newSocket()}get socket(){return this._socket}set socket(e){if(this.dataSocket=void 0,this.tlsOptions={},this._partialResponse="",this._socket){e.localPort===this._socket.localPort?this._removeSocketListeners(this.socket):this._closeControlSocket()}e&&(this._closingError=void 0,e.setTimeout(0),e.setEncoding(this._encoding),e.setKeepAlive(!0),e.on("data",(e=>this._onControlSocketData(e))),e.on("end",(()=>this.closeWithError(new Error("Server sent FIN packet unexpectedly, closing connection.")))),e.on("close",(e=>{e||this.closeWithError(new Error("Server closed connection unexpectedly."))})),this._setupDefaultErrorHandlers(e,"control socket")),this._socket=e}get dataSocket(){return this._dataSocket}set dataSocket(e){this._closeSocket(this._dataSocket),e&&(e.setTimeout(0),this._setupDefaultErrorHandlers(e,"data socket")),this._dataSocket=e}get encoding(){return this._encoding}set encoding(e){this._encoding=e,this.socket&&this.socket.setEncoding(e)}send(e){const t=e.startsWith("PASS")?"> PASS ###":`> ${e}`;this.log(t),this._socket.write(e+"\r\n",this.encoding)}request(e){return this.handle(e,((e,t)=>{e instanceof Error?t.reject(e):t.resolve(e)}))}handle(e,t){if(this._task){const e=new Error("User launched a task while another one is still running. Forgot to use 'await' or '.then()'?");e.stack+=`\nRunning task launched at: ${this._task.stack}`,this.closeWithError(e)}return new Promise(((r,o)=>{if(this._task={stack:(new Error).stack||"Unknown call stack",responseHandler:t,resolver:{resolve:e=>{this._stopTrackingTask(),r(e)},reject:e=>{this._stopTrackingTask(),o(e)}}},this._closingError){const e=new Error(`Client is closed because ${this._closingError.message}`);return e.stack+=`\nClosing reason: ${this._closingError.stack}`,e.code=void 0!==this._closingError.code?this._closingError.code:"0",void this._passToHandler(e)}this.socket.setTimeout(this.timeout),e&&this.send(e)}))}log(e){this.verbose&&console.log(e)}get hasTLS(){return"encrypted"in this._socket}_stopTrackingTask(){this.socket.setTimeout(0),this._task=void 0}_onControlSocketData(e){this.log(`< ${e}`);const t=this._partialResponse+e,r=(0,ve.parseControlResponse)(t);this._partialResponse=r.rest;for(const e of r.messages){const t=parseInt(e.substr(0,3),10),r={code:t,message:e},o=t>=400?new be(r):void 0;this._passToHandler(o||r)}}_passToHandler(e){this._task&&this._task.responseHandler(e,this._task.resolver)}_setupDefaultErrorHandlers(e,t){e.once("error",(e=>{e.message+=` (${t})`,this.closeWithError(e)})),e.once("close",(e=>{e&&this.closeWithError(new Error(`Socket closed due to transmission error (${t})`))})),e.once("timeout",(()=>{e.destroy(),this.closeWithError(new Error(`Timeout (${t})`))}))}_closeControlSocket(){this._removeSocketListeners(this._socket),this._socket.on("error",ke),this.send("QUIT"),this._closeSocket(this._socket)}_closeSocket(e){e&&(this._removeSocketListeners(e),e.on("error",ke),e.destroy())}_removeSocketListeners(e){e.removeAllListeners(),e.removeAllListeners("timeout"),e.removeAllListeners("data"),e.removeAllListeners("end"),e.removeAllListeners("error"),e.removeAllListeners("close"),e.removeAllListeners("connect")}_newSocket(){return new ye.Socket}};var Te,Se={},_e={},Ee={};Object.defineProperty(Ee,"__esModule",{value:!0}),Ee.FileInfo=Ee.FileType=void 0,function(e){e[e.Unknown=0]="Unknown",e[e.File=1]="File",e[e.Directory=2]="Directory",e[e.SymbolicLink=3]="SymbolicLink"}(Te||(Ee.FileType=Te={}));class $e{constructor(e){this.name=e,this.type=Te.Unknown,this.size=0,this.rawModifiedAt="",this.modifiedAt=void 0,this.permissions=void 0,this.hardLinkCount=void 0,this.link=void 0,this.group=void 0,this.user=void 0,this.uniqueID=void 0,this.name=e}get isDirectory(){return this.type===Te.Directory}get isSymbolicLink(){return this.type===Te.SymbolicLink}get isFile(){return this.type===Te.File}get date(){return this.rawModifiedAt}set date(e){this.rawModifiedAt=e}}Ee.FileInfo=$e,$e.UnixPermission={Read:4,Write:2,Execute:1},Object.defineProperty(_e,"__esModule",{value:!0}),_e.transformList=_e.parseLine=_e.testLine=void 0;const Pe=Ee,Oe=new RegExp("(\\S+)\\s+(\\S+)\\s+(?:(<DIR>)|([0-9]+))\\s+(\\S.*)");_e.testLine=function(e){return/^\d{2}/.test(e)&&Oe.test(e)},_e.parseLine=function(e){const t=e.match(Oe);if(null===t)return;const r=t[5];if("."===r||".."===r)return;const o=new Pe.FileInfo(r);return"<DIR>"===t[3]?(o.type=Pe.FileType.Directory,o.size=0):(o.type=Pe.FileType.File,o.size=parseInt(t[4],10)),o.rawModifiedAt=t[1]+" "+t[2],o},_e.transformList=function(e){return e};var Le={};Object.defineProperty(Le,"__esModule",{value:!0}),Le.transformList=Le.parseLine=Le.testLine=void 0;const De=Ee,Ce=new RegExp("([bcdelfmpSs-])(((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]?)))\\+?\\s*(\\d+)\\s+(?:(\\S+(?:\\s\\S+)*?)\\s+)?(?:(\\S+(?:\\s\\S+)*)\\s+)?(\\d+(?:,\\s*\\d+)?)\\s+((?:\\d+[-/]\\d+[-/]\\d+)|(?:\\S{3}\\s+\\d{1,2})|(?:\\d{1,2}\\s+\\S{3})|(?:\\d{1,2}æœˆ\\s+\\d{1,2}æ—¥))\\s+((?:\\d+(?::\\d+)?)|(?:\\d{4}å¹´))\\s(.*)");function Ie(e,t,r){let o=0;"-"!==e&&(o+=De.FileInfo.UnixPermission.Read),"-"!==t&&(o+=De.FileInfo.UnixPermission.Write);const n=r.charAt(0);return"-"!==n&&n.toUpperCase()!==n&&(o+=De.FileInfo.UnixPermission.Execute),o}Le.testLine=function(e){return Ce.test(e)},Le.parseLine=function(e){const t=e.match(Ce);if(null===t)return;const r=t[21];if("."===r||".."===r)return;const o=new De.FileInfo(r);switch(o.size=parseInt(t[18],10),o.user=t[16],o.group=t[17],o.hardLinkCount=parseInt(t[15],10),o.rawModifiedAt=t[19]+" "+t[20],o.permissions={user:Ie(t[4],t[5],t[6]),group:Ie(t[8],t[9],t[10]),world:Ie(t[12],t[13],t[14])},t[1].charAt(0)){case"d":o.type=De.FileType.Directory;break;case"e":case"l":o.type=De.FileType.SymbolicLink;break;case"b":case"c":case"f":case"-":o.type=De.FileType.File;break;default:o.type=De.FileType.Unknown}if(o.isSymbolicLink){const e=r.indexOf(" -> ");-1!==e&&(o.name=r.substring(0,e),o.link=r.substring(e+4))}return o},Le.transformList=function(e){return e};var xe={};Object.defineProperty(xe,"__esModule",{value:!0}),xe.parseMLSxDate=xe.transformList=xe.parseLine=xe.testLine=void 0;const Fe=Ee;function Ae(e,t){t.size=parseInt(e,10)}const Re={size:Ae,sizd:Ae,unique:(e,t)=>{t.uniqueID=e},modify:(e,t)=>{t.modifiedAt=je(e),t.rawModifiedAt=t.modifiedAt.toISOString()},type:(e,t)=>{if(e.startsWith("OS.unix=slink"))return t.type=Fe.FileType.SymbolicLink,t.link=e.substr(e.indexOf(":")+1),1;switch(e){case"file":t.type=Fe.FileType.File;break;case"dir":t.type=Fe.FileType.Directory;break;case"OS.unix=symlink":t.type=Fe.FileType.SymbolicLink;break;case"cdir":case"pdir":return 2;default:t.type=Fe.FileType.Unknown}return 1},"unix.mode":(e,t)=>{const r=e.substr(-3);t.permissions={user:parseInt(r[0],10),group:parseInt(r[1],10),world:parseInt(r[2],10)}},"unix.ownername":(e,t)=>{t.user=e},"unix.owner":(e,t)=>{void 0===t.user&&(t.user=e)},get"unix.uid"(){return this["unix.owner"]},"unix.groupname":(e,t)=>{t.group=e},"unix.group":(e,t)=>{void 0===t.group&&(t.group=e)},get"unix.gid"(){return this["unix.group"]}};function Me(e,t){const r=e.indexOf(t);return[e.substr(0,r),e.substr(r+t.length)]}function je(e){return new Date(Date.UTC(+e.slice(0,4),+e.slice(4,6)-1,+e.slice(6,8),+e.slice(8,10),+e.slice(10,12),+e.slice(12,14),+e.slice(15,18)))}xe.testLine=function(e){return/^\S+=\S+;/.test(e)||e.startsWith(" ")},xe.parseLine=function(e){const[t,r]=Me(e," ");if(""===r||"."===r||".."===r)return;const o=new Fe.FileInfo(r),n=t.split(";");for(const e of n){const[t,r]=Me(e,"=");if(!r)continue;const n=Re[t.toLowerCase()];if(!n)continue;if(2===n(r,o))return}return o},xe.transformList=function(e){const t=new Map;for(const r of e)r.isSymbolicLink||void 0===r.uniqueID||t.set(r.uniqueID,r);const r=[];for(const o of e){if(o.isSymbolicLink&&void 0!==o.uniqueID&&void 0===o.link){const e=t.get(o.uniqueID);void 0!==e&&(o.link=e.name)}!o.name.includes("/")&&r.push(o)}return r},xe.parseMLSxDate=je;var We=de&&de.__createBinding||(Object.create?function(e,t,r,o){void 0===o&&(o=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,o,n)}:function(e,t,r,o){void 0===o&&(o=r),e[o]=t[r]}),Ne=de&&de.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),Ue=de&&de.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var r in e)"default"!==r&&Object.prototype.hasOwnProperty.call(e,r)&&We(t,e,r);return Ne(t,e),t};Object.defineProperty(Se,"__esModule",{value:!0}),Se.parseList=void 0;const qe=[Ue(_e),Ue(Le),Ue(xe)];function Be(e){return""!==e.trim()}function ze(e){return!e.startsWith("total")}const He=/\r?\n/;Se.parseList=function(e){const t=e.split(He).filter(Be).filter(ze);if(0===t.length)return[];const r=t[t.length-1],o=(n=r,qe.find((e=>!0===e.testLine(n))));var n;if(!o)throw new Error("This library only supports MLSD, Unix- or DOS-style directory listing. Your FTP server seems to be using another format. You can see the transmitted listing when setting `client.ftp.verbose = true`. You can then provide a custom parser to `client.parseList`, see the documentation for details.");const s=t.map(o.parseLine).filter((e=>void 0!==e));return o.transformList(s)};var Ve={};Object.defineProperty(Ve,"__esModule",{value:!0}),Ve.ProgressTracker=void 0;function Ye(){}Ve.ProgressTracker=class{constructor(){this.bytesOverall=0,this.intervalMs=500,this.onStop=Ye,this.onHandle=Ye}reportTo(e=Ye){this.onHandle=e}start(e,t,r){let o=0;this.onStop=function(e,t){const r=setInterval(t,e),o=e=>{clearInterval(r),e&&t(),t=Ye};return t(),o}(this.intervalMs,(()=>{const n=e.bytesRead+e.bytesWritten;this.bytesOverall+=n-o,o=n,this.onHandle({name:t,type:r,bytes:n,bytesOverall:this.bytesOverall})}))}stop(){this.onStop(!1)}updateAndStop(){this.onStop(!0)}};var Ge={};Object.defineProperty(Ge,"__esModule",{value:!0}),Ge.StringWriter=void 0;const Ke=u;class Je extends Ke.Writable{constructor(){super(...arguments),this.buf=Buffer.alloc(0)}_write(e,t,r){e instanceof Buffer?(this.buf=Buffer.concat([this.buf,e]),r(null)):r(new Error("StringWriter expects chunks of type 'Buffer'."))}getText(e){return this.buf.toString(e)}}Ge.StringWriter=Je;var Ze={};Object.defineProperty(Ze,"__esModule",{value:!0}),Ze.ipIsPrivateV4Address=Ze.upgradeSocket=Ze.describeAddress=Ze.describeTLS=void 0;const Qe=c;Ze.describeTLS=function(e){if(e instanceof Qe.TLSSocket){const t=e.getProtocol();return t||"Server socket or disconnected client socket"}return"No encryption"},Ze.describeAddress=function(e){return"IPv6"===e.remoteFamily?`[${e.remoteAddress}]:${e.remotePort}`:`${e.remoteAddress}:${e.remotePort}`},Ze.upgradeSocket=function(e,t){return new Promise(((r,o)=>{const n=Object.assign({},t,{socket:e}),s=(0,Qe.connect)(n,(()=>{!1!==n.rejectUnauthorized&&!s.authorized?o(s.authorizationError):(s.removeAllListeners("error"),r(s))})).once("error",(e=>{o(e)}))}))},Ze.ipIsPrivateV4Address=function(e=""){e.startsWith("::ffff:")&&(e=e.substr(7));const t=e.split(".").map((e=>parseInt(e,10)));return 10===t[0]||172===t[0]&&t[1]>=16&&t[1]<=31||192===t[0]&&168===t[1]||"127.0.0.1"===e};var Xe={};Object.defineProperty(Xe,"__esModule",{value:!0}),Xe.downloadTo=Xe.uploadFrom=Xe.connectForPassiveTransfer=Xe.parsePasvResponse=Xe.enterPassiveModeIPv4=Xe.parseEpsvResponse=Xe.enterPassiveModeIPv6=void 0;const et=Ze,tt=u,rt=c,ot=fe;function nt(e){const t=e.match(/[|!]{3}(.+)[|!]/);if(null===t||void 0===t[1])throw new Error(`Can't parse response to 'EPSV': ${e}`);const r=parseInt(t[1],10);if(Number.isNaN(r))throw new Error(`Can't parse response to 'EPSV', port is not a number: ${e}`);return r}function st(e){const t=e.match(/([-\d]+,[-\d]+,[-\d]+,[-\d]+),([-\d]+),([-\d]+)/);if(null===t||4!==t.length)throw new Error(`Can't parse response to 'PASV': ${e}`);return{host:t[1].replace(/,/g,"."),port:256*(255&parseInt(t[2],10))+(255&parseInt(t[3],10))}}function it(e,t,r){return new Promise(((o,n)=>{let s=r._newSocket();const i=function(e){e.message="Can't open data connection in passive mode: "+e.message,n(e)},a=function(){s.destroy(),n(new Error(`Timeout when trying to open data connection to ${e}:${t}`))};s.setTimeout(r.timeout),s.on("error",i),s.on("timeout",a),s.connect({port:t,host:e,family:r.ipFamily},(()=>{r.socket instanceof rt.TLSSocket&&(s=(0,rt.connect)(Object.assign({},r.tlsOptions,{socket:s,session:r.socket.getSession()}))),s.removeListener("error",i),s.removeListener("timeout",a),r.dataSocket=s,o()}))}))}Xe.enterPassiveModeIPv6=async function(e){const t=await e.request("EPSV"),r=nt(t.message);if(!r)throw new Error("Can't parse EPSV response: "+t.message);const o=e.socket.remoteAddress;if(void 0===o)throw new Error("Control socket is disconnected, can't get remote address.");return await it(o,r,e),t},Xe.parseEpsvResponse=nt,Xe.enterPassiveModeIPv4=async function(e){const t=await e.request("PASV"),r=st(t.message);if(!r)throw new Error("Can't parse PASV response: "+t.message);const o=e.socket.remoteAddress;return(0,et.ipIsPrivateV4Address)(r.host)&&o&&!(0,et.ipIsPrivateV4Address)(o)&&(r.host=o),await it(r.host,r.port,e),t},Xe.parsePasvResponse=st,Xe.connectForPassiveTransfer=it;class at{constructor(e,t){this.ftp=e,this.progress=t,this.response=void 0,this.dataTransferDone=!1}onDataStart(e,t){if(void 0===this.ftp.dataSocket)throw new Error("Data transfer should start but there is no data connection.");this.ftp.socket.setTimeout(0),this.ftp.dataSocket.setTimeout(this.ftp.timeout),this.progress.start(this.ftp.dataSocket,e,t)}onDataDone(e){this.progress.updateAndStop(),this.ftp.socket.setTimeout(this.ftp.timeout),this.ftp.dataSocket&&this.ftp.dataSocket.setTimeout(0),this.dataTransferDone=!0,this.tryResolve(e)}onControlDone(e,t){this.response=t,this.tryResolve(e)}onError(e,t){this.progress.updateAndStop(),this.ftp.socket.setTimeout(this.ftp.timeout),this.ftp.dataSocket=void 0,e.reject(t)}onUnexpectedRequest(e){const t=new Error(`Unexpected FTP response is requesting an answer: ${e.message}`);this.ftp.closeWithError(t)}tryResolve(e){this.dataTransferDone&&void 0!==this.response&&(this.ftp.dataSocket=void 0,e.resolve(this.response))}}Xe.uploadFrom=function(e,t){const r=new at(t.ftp,t.tracker),o=`${t.command} ${t.remotePath}`;return t.ftp.handle(o,((o,n)=>{if(o instanceof Error)r.onError(n,o);else if(150===o.code||125===o.code){const o=t.ftp.dataSocket;if(!o)return void r.onError(n,new Error("Upload should begin but no data connection is available."));const c=!("getCipher"in o)||void 0!==o.getCipher();s=o,i="secureConnect",a=()=>{t.ftp.log(`Uploading to ${(0,et.describeAddress)(o)} (${(0,et.describeTLS)(o)})`),r.onDataStart(t.remotePath,t.type),(0,tt.pipeline)(e,o,(e=>{e?r.onError(n,e):r.onDataDone(n)}))},!0===c?a():s.once(i,(()=>a()))}else(0,ot.positiveCompletion)(o.code)?r.onControlDone(n,o):(0,ot.positiveIntermediate)(o.code)&&r.onUnexpectedRequest(o);var s,i,a}))},Xe.downloadTo=function(e,t){if(!t.ftp.dataSocket)throw new Error("Download will be initiated but no data connection is available.");const r=new at(t.ftp,t.tracker);return t.ftp.handle(t.command,((o,n)=>{if(o instanceof Error)r.onError(n,o);else if(150===o.code||125===o.code){const o=t.ftp.dataSocket;if(!o)return void r.onError(n,new Error("Download should begin but no data connection is available."));t.ftp.log(`Downloading from ${(0,et.describeAddress)(o)} (${(0,et.describeTLS)(o)})`),r.onDataStart(t.remotePath,t.type),(0,tt.pipeline)(o,e,(e=>{e?r.onError(n,e):r.onDataDone(n)}))}else 350===o.code?t.ftp.send("RETR "+t.remotePath):(0,ot.positiveCompletion)(o.code)?r.onControlDone(n,o):(0,ot.positiveIntermediate)(o.code)&&r.onUnexpectedRequest(o)}))},Object.defineProperty(he,"__esModule",{value:!0}),he.Client=void 0;const ct=i,lt=a,dt=c,ut=l,ht=pe,pt=Se,ft=Ve,mt=Ge,gt=xe,wt=Ze,yt=Xe,vt=fe,bt=(0,ut.promisify)(ct.readdir),kt=(0,ut.promisify)(ct.mkdir),Tt=(0,ut.promisify)(ct.stat),St=(0,ut.promisify)(ct.open),_t=(0,ut.promisify)(ct.close),Et=(0,ut.promisify)(ct.unlink);async function $t(e){try{return await e()}catch(e){return}}he.Client=class{constructor(e=3e4){this.availableListCommands=["LIST -a","LIST"],this.ftp=new ht.FTPContext(e),this.prepareTransfer=this._enterFirstCompatibleMode([yt.enterPassiveModeIPv6,yt.enterPassiveModeIPv4]),this.parseList=pt.parseList,this._progressTracker=new ft.ProgressTracker}close(){this.ftp.close(),this._progressTracker.stop()}get closed(){return this.ftp.closed}connect(e="localhost",t=21){return this.ftp.reset(),this.ftp.socket.connect({host:e,port:t,family:this.ftp.ipFamily},(()=>this.ftp.log(`Connected to ${(0,wt.describeAddress)(this.ftp.socket)} (${(0,wt.describeTLS)(this.ftp.socket)})`))),this._handleConnectResponse()}connectImplicitTLS(e="localhost",t=21,r={}){return this.ftp.reset(),this.ftp.socket=(0,dt.connect)(t,e,r,(()=>this.ftp.log(`Connected to ${(0,wt.describeAddress)(this.ftp.socket)} (${(0,wt.describeTLS)(this.ftp.socket)})`))),this.ftp.tlsOptions=r,this._handleConnectResponse()}_handleConnectResponse(){return this.ftp.handle(void 0,((e,t)=>{e instanceof Error?t.reject(e):(0,vt.positiveCompletion)(e.code)?t.resolve(e):t.reject(new ht.FTPError(e))}))}send(e,t=!1){return t?(this.ftp.log("Deprecated call using send(command, flag) with boolean flag to ignore errors. Use sendIgnoringError(command)."),this.sendIgnoringError(e)):this.ftp.request(e)}sendIgnoringError(e){return this.ftp.handle(e,((e,t)=>{e instanceof ht.FTPError?t.resolve({code:e.code,message:e.message}):e instanceof Error?t.reject(e):t.resolve(e)}))}async useTLS(e={},t="AUTH TLS"){const r=await this.send(t);return this.ftp.socket=await(0,wt.upgradeSocket)(this.ftp.socket,e),this.ftp.tlsOptions=e,this.ftp.log(`Control socket is using: ${(0,wt.describeTLS)(this.ftp.socket)}`),r}login(e="anonymous",t="guest"){return this.ftp.log(`Login security: ${(0,wt.describeTLS)(this.ftp.socket)}`),this.ftp.handle("USER "+e,((e,r)=>{e instanceof Error?r.reject(e):(0,vt.positiveCompletion)(e.code)?r.resolve(e):331===e.code?this.ftp.send("PASS "+t):r.reject(new ht.FTPError(e))}))}async useDefaultSettings(){const e=(await this.features()).has("MLST");this.availableListCommands=e?["MLSD","LIST -a","LIST"]:["LIST -a","LIST"],await this.send("TYPE I"),await this.sendIgnoringError("STRU F"),await this.sendIgnoringError("OPTS UTF8 ON"),e&&await this.sendIgnoringError("OPTS MLST type;size;modify;unique;unix.mode;unix.owner;unix.group;unix.ownername;unix.groupname;"),this.ftp.hasTLS&&(await this.sendIgnoringError("PBSZ 0"),await this.sendIgnoringError("PROT P"))}async access(e={}){var t,r;const o=!0===e.secure;let n;if(n="implicit"===e.secure?await this.connectImplicitTLS(e.host,e.port,e.secureOptions):await this.connect(e.host,e.port),o){const o=null!==(t=e.secureOptions)&&void 0!==t?t:{};o.host=null!==(r=o.host)&&void 0!==r?r:e.host,await this.useTLS(o)}return await this.sendIgnoringError("OPTS UTF8 ON"),await this.login(e.user,e.password),await this.useDefaultSettings(),n}async pwd(){const e=await this.send("PWD"),t=e.message.match(/"(.+)"/);if(null===t||void 0===t[1])throw new Error(`Can't parse response to command 'PWD': ${e.message}`);return t[1]}async features(){const e=await this.sendIgnoringError("FEAT"),t=new Map;return e.code<400&&(0,vt.isMultiline)(e.message)&&e.message.split("\n").slice(1,-1).forEach((e=>{const r=e.trim().split(" ");t.set(r[0],r[1]||"")})),t}async cd(e){const t=await this.protectWhitespace(e);return this.send("CWD "+t)}async cdup(){return this.send("CDUP")}async lastMod(e){const t=await this.protectWhitespace(e),r=(await this.send(`MDTM ${t}`)).message.slice(4);return(0,gt.parseMLSxDate)(r)}async size(e){const t=`SIZE ${await this.protectWhitespace(e)}`,r=await this.send(t),o=parseInt(r.message.slice(4),10);if(Number.isNaN(o))throw new Error(`Can't parse response to command '${t}' as a numerical value: ${r.message}`);return o}async rename(e,t){const r=await this.protectWhitespace(e),o=await this.protectWhitespace(t);return await this.send("RNFR "+r),this.send("RNTO "+o)}async remove(e,t=!1){const r=await this.protectWhitespace(e);return t?this.sendIgnoringError(`DELE ${r}`):this.send(`DELE ${r}`)}trackProgress(e){this._progressTracker.bytesOverall=0,this._progressTracker.reportTo(e)}async uploadFrom(e,t,r={}){return this._uploadWithCommand(e,t,"STOR",r)}async appendFrom(e,t,r={}){return this._uploadWithCommand(e,t,"APPE",r)}async _uploadWithCommand(e,t,r,o){return"string"==typeof e?this._uploadLocalFile(e,t,r,o):this._uploadFromStream(e,t,r)}async _uploadLocalFile(e,t,r,o){const n=await St(e,"r"),s=(0,ct.createReadStream)("",{fd:n,start:o.localStart,end:o.localEndInclusive,autoClose:!1});try{return await this._uploadFromStream(s,t,r)}finally{await $t((()=>_t(n)))}}async _uploadFromStream(e,t,r){const o=e=>this.ftp.closeWithError(e);e.once("error",o);try{const o=await this.protectWhitespace(t);return await this.prepareTransfer(this.ftp),await(0,yt.uploadFrom)(e,{ftp:this.ftp,tracker:this._progressTracker,command:r,remotePath:o,type:"upload"})}finally{e.removeListener("error",o)}}async downloadTo(e,t,r=0){return"string"==typeof e?this._downloadToFile(e,t,r):this._downloadToStream(e,t,r)}async _downloadToFile(e,t,r){const o=r>0,n=o?"r+":"w",s=await St(e,n),i=(0,ct.createWriteStream)("",{fd:s,start:r,autoClose:!1});try{return await this._downloadToStream(i,t,r)}catch(t){const r=await $t((()=>Tt(e))),n=r&&r.size>0;throw!o&&!n&&await $t((()=>Et(e))),t}finally{await $t((()=>_t(s)))}}async _downloadToStream(e,t,r){const o=e=>this.ftp.closeWithError(e);e.once("error",o);try{const o=await this.protectWhitespace(t);return await this.prepareTransfer(this.ftp),await(0,yt.downloadTo)(e,{ftp:this.ftp,tracker:this._progressTracker,command:r>0?`REST ${r}`:`RETR ${o}`,remotePath:o,type:"download"})}finally{e.removeListener("error",o),e.end()}}async list(e=""){const t=await this.protectWhitespace(e);let r;for(const e of this.availableListCommands){const o=""===t?e:`${e} ${t}`;await this.prepareTransfer(this.ftp);try{const t=await this._requestListWithCommand(o);return this.availableListCommands=[e],t}catch(e){if(!(e instanceof ht.FTPError))throw e;r=e}}throw r}async _requestListWithCommand(e){const t=new mt.StringWriter;await(0,yt.downloadTo)(t,{ftp:this.ftp,tracker:this._progressTracker,command:e,remotePath:"",type:"list"});const r=t.getText(this.ftp.encoding);return this.ftp.log(r),this.parseList(r)}async removeDir(e){return this._exitAtCurrentDirectory((async()=>{await this.cd(e);const t=await this.pwd();await this.clearWorkingDir();"/"===t||(await this.cdup(),await this.removeEmptyDir(t))}))}async clearWorkingDir(){for(const e of await this.list())e.isDirectory?(await this.cd(e.name),await this.clearWorkingDir(),await this.cdup(),await this.removeEmptyDir(e.name)):await this.remove(e.name)}async uploadFromDir(e,t){return this._exitAtCurrentDirectory((async()=>(t&&await this.ensureDir(t),await this._uploadToWorkingDir(e))))}async _uploadToWorkingDir(e){const t=await bt(e);for(const r of t){const t=(0,lt.join)(e,r),o=await Tt(t);o.isFile()?await this.uploadFrom(t,r):o.isDirectory()&&(await this._openDir(r),await this._uploadToWorkingDir(t),await this.cdup())}}async downloadToDir(e,t){return this._exitAtCurrentDirectory((async()=>(t&&await this.cd(t),await this._downloadFromWorkingDir(e))))}async _downloadFromWorkingDir(e){await async function(e){try{await Tt(e)}catch(t){await kt(e,{recursive:!0})}}(e);for(const t of await this.list()){const r=(0,lt.join)(e,t.name);t.isDirectory?(await this.cd(t.name),await this._downloadFromWorkingDir(r),await this.cdup()):t.isFile&&await this.downloadTo(r,t.name)}}async ensureDir(e){e.startsWith("/")&&await this.cd("/");const t=e.split("/").filter((e=>""!==e));for(const e of t)await this._openDir(e)}async _openDir(e){await this.sendIgnoringError("MKD "+e),await this.cd(e)}async removeEmptyDir(e){const t=await this.protectWhitespace(e);return this.send(`RMD ${t}`)}async protectWhitespace(e){if(!e.startsWith(" "))return e;const t=await this.pwd();return(t.endsWith("/")?t:t+"/")+e}async _exitAtCurrentDirectory(e){const t=await this.pwd();try{return await e()}finally{this.closed||await $t((()=>this.cd(t)))}}_enterFirstCompatibleMode(e){return async t=>{let r;t.log("Trying to find optimal transfer strategy...");for(const o of e)try{const e=await o(t);return t.log("Optimal transfer strategy found."),this.prepareTransfer=o,e}catch(e){r=e}throw new Error(`None of the available transfer strategies work. Last error response was '${r}'.`)}}async upload(e,t,r={}){return this.ftp.log("Warning: upload() has been deprecated, use uploadFrom()."),this.uploadFrom(e,t,r)}async append(e,t,r={}){return this.ftp.log("Warning: append() has been deprecated, use appendFrom()."),this.appendFrom(e,t,r)}async download(e,t,r=0){return this.ftp.log("Warning: download() has been deprecated, use downloadTo()."),this.downloadTo(e,t,r)}async uploadDir(e,t){return this.ftp.log("Warning: uploadDir() has been deprecated, use uploadFromDir()."),this.uploadFromDir(e,t)}async downloadDir(e){return this.ftp.log("Warning: downloadDir() has been deprecated, use downloadToDir()."),this.downloadToDir(e)}};var Pt={};Object.defineProperty(Pt,"__esModule",{value:!0}),function(e){var t=de&&de.__createBinding||(Object.create?function(e,t,r,o){void 0===o&&(o=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,o,n)}:function(e,t,r,o){void 0===o&&(o=r),e[o]=t[r]}),r=de&&de.__exportStar||function(e,r){for(var o in e)"default"===o||Object.prototype.hasOwnProperty.call(r,o)||t(r,e,o)};Object.defineProperty(e,"__esModule",{value:!0}),e.enterPassiveModeIPv6=e.enterPassiveModeIPv4=void 0,r(he,e),r(pe,e),r(Ee,e),r(Se,e),r(Pt,e);var o=Xe;Object.defineProperty(e,"enterPassiveModeIPv4",{enumerable:!0,get:function(){return o.enterPassiveModeIPv4}}),Object.defineProperty(e,"enterPassiveModeIPv6",{enumerable:!0,get:function(){return o.enterPassiveModeIPv6}})}(ue);const Ot=async()=>{const e=await le();if(!e)return{status:"error",text:W.red("\nCouldn't get 'brifka.config.json' file.\n")};const t=new ue.Client,{user:r,password:o,port:n,host:s,secure:i}=e.ftp;return new Promise((async e=>{try{await t.access({host:s,password:o,user:r,port:"string"==typeof n&&"default"===n?void 0:n,secure:i}),e({status:"success",client:t})}catch(r){t.close(),e({status:"error",text:`FTP error: ${r?.code}`})}}))},Lt=e=>{if(!e.peek())return void console.log(`\n${Object.values(z).join("\n\n")}\n`);const t=e.peek();Object.keys(z).find((e=>e==t))?.length?console.log(`\n${z[t]}\n`):(console.error(W.red(`\nCommand '${t}' doesn't exist.`)),console.log(U("Type 'brifka help' to view documentation of all commands.","Help")))},Dt=e=>{const t=(...e)=>n.join("./.brifka",...e);H(t("mem/commits")),H(t("mem/tracked")),H(t("mem/head")),(async e=>{const t=n.normalize(e),r=n.parse(t),s=[...r.dir.split(n.sep),r.name].filter((e=>e.length>0));for(let e=0;e<s.length;e++)try{await o.mkdir(n.resolve(process.cwd(),...s.slice(0,e+1)))}catch{}})(t("rep"));H("brifka.config.json",JSON.stringify({ftp:{host:"localhost",port:"default",user:"anonymus",password:"anonymus@",directory:""}},void 0,2)),H(".brignore","brifka.config.json")},Ct=async e=>{const r=e.next();if(!r||r.length<=0)return void console.error(W.red("\nTrack command requires <directory_path> | <file_path> argument.\n"));const s=n.resolve(process.cwd(),r);let i;try{i=await o.stat(s)}catch{return void console.error(W.red(`\nFile or directory '${r}' doesn't exist.\n`))}let a=new Set;try{const e=await Y(".brignore");if("boolean"==typeof e&&!e)throw new Error;a=new Set([...X(e),...ee])}catch{a=new Set(ee)}const c=".brifka/mem/tracked",l=await Y(c);if("string"!=typeof l)return void console.error(W.red("\nRepository memory corrupted :/\n"));const d=new Set(J(l));if(i.isDirectory()){const e=new Set;await G(s,e,a);const o=new Set(Array.from(e).filter((e=>!d.has(e))));await V(c,K(Array.from(o))+t.EOL),console.log(`\n${W.green(o.size)} new files added to tracked stage from directory '${r}'.\n`)}else if(i.isFile()){const e=n.relative(process.cwd(),s);if(d.has(e))return void console.error(W.red(`\nFile '${e}' is already tracked.\n`));await V(c,K([e])+t.EOL),console.log(W.green(`\nAdded '${r}' to tracked stage.\n`))}},It=async e=>{const t=e.next();if(!t||t.length<=0)return void console.error(W.red("\nUntrack command requires <directory_path> | <file_path> | . argument.\n"));const r=".brifka/mem/tracked",s=await Y(r);if("string"!=typeof s)return void console.error(W.red("\nRepository memory corrupted :/\n"));const i=n.normalize(t),a=n.resolve(process.cwd(),i),c=new Set(J(s));let l;try{l=await o.stat(a)}catch{return void console.log(W.red(`\nFile or directory '${t}' doesn't exist.\n`))}if(l.isFile())c.delete(i)?console.log(`\nRemoved '${t}' from tracked stage.\n`):console.log(W.red(`\nFile '${t}' wasn't tracked.\n`));else if(l.isDirectory()){const e=new Set;await G(a,e);let r=0;for(const t of e)c.delete(t)&&r++;console.log(`\n${W.red(r)} files removed from tracked stage from directory '${t}'.\n`)}await H(r,K(Array.from(c)))},xt=async e=>{const r=e.next();if(!r||r.length<=0)return void console.error(W.red("\nCommit command requires <commit_name> argument.\n"));const o=s.randomBytes(32).toString("hex");await V(".brifka/mem/commits",`${Z([{title:r,hash:o,timestamp:Date.now()}])}${t.EOL}`);const n=await Y(".brifka/mem/tracked");if("string"==typeof n&&n.length<=0)return void console.error(W.red("\nThere aren't any files in tracked stage.\n"));if("boolean"==typeof n&&!n)return void console.error(W.red("\nRepository memory corrupted :/\n"));const i=J(n),a=[];for(const e of i){const t=await Y(e);if("boolean"==typeof t&&!t)continue;const r=s.createHash("sha256").update(t).digest("hex");await te(e,r),a.push({path:e,hash:r})}var c;await H(`.brifka/rep/${o.slice(0,8)}`,(c=a,c.map((({path:e,hash:t})=>`${e.length}${e}${t}`)).join(t.EOL))),await H(".brifka/mem/head",o),console.log(W.green("\nSuccessfully commited\n"))},Ft=async e=>{const t=await Y(".brifka/mem/commits");if("boolean"==typeof t&&!t)return;const r=Q(t);if(r.length<=0)return void console.error(W.red("\nThere aren't any commits yet.\n"));const o=await Y(".brifka/mem/head");console.log(`\n${r.reverse().map((({title:e,hash:t,timestamp:r})=>`${W.yellow("commit: "+t)}${o&&o===t?W.blue(" <- HEAD"):""}\nDate: ${new Date(r).toLocaleString()}\n\n\t${e}`)).join("\n\n")}\n`)},At=async e=>{const r=e.next();if(!r||r.length<=0)return void console.error(W.red("\nChange command requires <commit_hash> argument.\n"));const o=await Y(".brifka/mem/commits");if("boolean"==typeof o&&!o)return;const n=Q(o).filter((({hash:e})=>r==e))[0];if(!n)return void console.error(`\nCommit with hash '${r}' doesn't exist.\n`);oe(process.cwd());const s=`.brifka/rep/${n.hash.slice(0,8)}`,i=await Y(s);if("boolean"==typeof i&&!i)return;const a=(e=>{const r=e.split(t.EOL),o=[];try{r.forEach((e=>{if(e.length<=0)return;let t=0,r="";for(;""!=e[t]&&t<e.length;t++)r+=e[t];if(++t>=e.length)throw new Error;let n="";for(;t<e.length&&t<r.length+1+Number(r);t++)n+=e[t];if(""!=e[t])throw new Error;if(++t>=e.length)throw new Error;let s="";for(;t<e.length;t++)s+=e[t];o.push({path:n,hash:s})}))}catch{return console.error(W.red("\nRepository memory corrupted :/\n")),[]}return o})(i),c=[];let l=0;for(const{hash:e,path:t}of a){const r=await Y(`.brifka/rep/${e.slice(0,8)}`);"boolean"!=typeof r||r?(await H(t,r),l++):c.push(t)}await H(".brifka/mem/head",r),c.length>0&&console.error(`\n${W.red(c.length)} files failed to load from repository.`),console.log(`\n${W.green(l)} files successfully loaded from repository.\n`)},Rt=async e=>{const t=e.next(),r=await Y(".brifka/mem/tracked");if("boolean"==typeof r&&!r)return;const o=new Set(J(r));let n=new Set;try{const e=await Y(".brignore");if("boolean"==typeof e&&!e)throw new Error;n=new Set([...X(e),...ne])}catch{}const s=new Set;if(await G(process.cwd(),s,n),"full"===t)return void((e,t)=>{console.log(W.green("\ntracked\n======="));for(const t of e)console.log(W.green(t));console.log(W.red("\nnot tracked\n==========="));for(const r of t)e.has(r)||console.log(W.red(r));console.log()})(o,s);let i=0;for(const e of s)o.has(e)||i++;console.log(`\n${W.green(o.size)} files are in tracked stage.\n${W.red(i)} files aren't in tracked stage.\n`)},Mt=async e=>{const t=".brifka/mem/commits",r=await Y(t);if("boolean"==typeof r&&!r)return void console.error(W.red("\nRepository memory corrupted :/\n"));let o=Q(r);const n=o.pop();n?(await H(t,Z(o)),console.error(`\n${W.green("Successfully removed last commit.")}\n\n${W.yellow(`commit: ${n.hash}`)}\nDate: ${new Date(n.timestamp).toLocaleString()}\n\n\t${n.title}\n`)):console.error(W.red("\nThere aren't any commits yet.\n"))},jt=e=>{const t=e.next();if(!t||t.length<=0)console.error(W.red("\nFtp command requires pull | push | list argument.\n"));else switch(t){case"pull":(async()=>{const e=await le();if(!e)return void console.error(W.red("\nCouldn't load config file.\n"));e.ftp;const t=await Ot();"error"!==t.status||console.error(W.red(`\n${t.text}\n`))})();break;case"push":(async()=>{await le()||console.error(W.red("\nCouldn't load config file.\n"))})();break;case"list":(async e=>{let t=e.next();!1===t&&(t=".");const r=await le();if(!r)return void console.error(W.red("\nCouldn't load config file.\n"));const{directory:o}=r.ftp,s=await Ot();if("error"===s.status)return void console.error(W.red(`\n${s.text}\n`));const{client:i}=s;try{const e=await i.list(n.join(o,t).replace("\\","/"));console.log();for(const r of e){const e=r.isDirectory?W.cyan("D"):r.isFile?W.yellow("F"):" ";console.log(`${e} ${n.join(t,r.name)}`)}console.log()}catch(e){console.log(e,"err")}i.close()})(e);break;default:console.error(W.red(`\n'${t}' is not valid argument. Expected pull | push | list argument.\n`))}};(async()=>{const e=new N(process.argv.slice(2)),t=e.peek();let r=!1;try{if(!(await o.stat(n.resolve(process.cwd(),".brifka"))).isDirectory())throw new Error;r=!0}catch{}if(!r&&(!t||"init"!=t&&"help"!=t))return console.log(W.red("\nBrifka repository is not initialized.")),void console.log(U("Type 'brifka init' to initialize repository.","Help"));(e=>{const t=e.next();switch(t){case"help":Lt(e);break;case"init":Dt(e);break;case"track":Ct(e);break;case"untrack":It(e);break;case"commit":xt(e);break;case"commits":Ft(e);break;case"change":At(e);break;case"log":Rt(e);break;case"uncommit":Mt(e);break;case"ftp":jt(e);break;default:console.error(W.red(`\nCommand '${t}' doesn't exist.`)),console.log(U("To get documentation of all commands type 'brifka help' or 'brifka help <command_name>' to get documentation of specific command.","Help"))}})(e)})();
